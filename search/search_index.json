{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programacion","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"web/js/","text":"js Estructuras de control C\u00f3digo Denominaci\u00f3n if(condici\u00f3n) { c\u00f3digo true }else { c\u00f3digo false} Estructura de control condicional (condici\u00f3n) ? valor_true : valor_false Operador de control condicional switch(expresi\u00f3n) { case condici\u00f3n_1: c\u00f3digo condici\u00f3n_1 [break;] \u2026 case condici\u00f3n_n: c\u00f3digo condici\u00f3n_n [break;] default: c\u00f3digo default} Estructura de control condicional basada en la evaluaci\u00f3n del valor de una expresi\u00f3n for(ini; condici\u00f3n; actualizaci\u00f3n){ c\u00f3digo bucle} Bucle condicional while(condici\u00f3n) { c\u00f3digo bucle} Bucle incondicional do { c\u00f3digo bucle} while(condicion) Bucle incondicional break Salida de un bloque de c\u00f3digo continue Parada de la ejecuci\u00f3n de un bucle para volver a evaluar la condici\u00f3n de parada try { c\u00f3digo js}catch(err) { c\u00f3digo que gestiona el error}finally { c\u00f3digo a ejecutar haya o no error} Captura y gesti\u00f3n de errores en el c\u00f3digo Operadores Operador Denominaci\u00f3n = Asignaci\u00f3n +, -, \\*, /, % Operadores aritm\u00e9ticos (act\u00faan sobre valores num\u00e9ricos) ++, -- Incremento, decremento **+=, -=, \\*=, /=, %=** Operaci\u00f3n aritm\u00e9tica + Asignaci\u00f3n +, += Concatenaci\u00f3n de Strings ==, !=, >, <, >=, <= Comparadores de valor **===** (igual valor e igual tipo)**!==** (distinto valor y distinto tipo) Comparadores de valor y tipo &&, ||, ! Operadores l\u00f3gicos < html > < head > < script > var a = 3 ; function mostrarVariable ( valor ) { alert ( valor ); // Aqu\u00ed mostramos el valor que recibe como par\u00e1metro alert ( a ); // Aqu\u00ed, el valor de la variable global } </ script > </ head > < body > Ejemplo sencillo de uso de < i > JavaScript </ i > < input type = \"button\" value = \"Pulsar...\" onclick = \"mostrarVariable(a)\" /> < script > alert ( a ); a = 5 ; </ script > </ body > </ html > La secuencia de acciones realizadas por el int\u00e9rprete JavaScript al interpretar este c\u00f3digo es: Crear una variable a y asignarle el valor num\u00e9rico 3.* * Crear una funci\u00f3n mostrarVariable que queda a la espera de ser invocada. Invocar a la funci\u00f3n alert para mostrar el valor actual de a . Cambiar el valor de a asign\u00e1ndole el valor num\u00e9rico 5. \u00bfCu\u00e1ndo se invoca la funci\u00f3n que hemos creado? En este caso, al pulsar el bot\u00f3n que hemos a\u00f1adido en el cuerpo del documento. Para ello utilizamos su atributo onclick , en el que se indica el c\u00f3digo JavaScript a ejecutar al \"hacer clic\" sobre el elemento. Lo que en realidad estamos haciendo con esa definici\u00f3n es asociar una funcionalidad a un evento, pero de momento no debes preocuparte por ello, en las siguientes secciones trataremos los eventos HTML en detalle. eventos Estos son algunos de los eventos HTML que m\u00e1s habitualmente se procesan en las aplicaciones web. Aunque procesando estos eventos podr\u00edas desarrollar cualquier aplicaci\u00f3n web t\u00edpica, como ya sabes, puedes encontrar la lista completa de eventos HTML en la documentaci\u00f3n de referencia de la W3C . Recuerda que para procesar un evento tienes que dar valor a la propiedad correspondiente en el elemento HTML, por ejemplo, para procesar el evento click debes fijar la propiedad onclick : click : se produce cuando el usuario hace click sobre el elemento HTML. mouseover : se produce cuando el usuario entra con el rat\u00f3n dentro del elemento HTML. mouseout : se produce cuando el usuario sale con el rat\u00f3n del elemento HTML. focus : se produce cuando el elemento HTML recibe el foco. blur : se produce cuando el elemento HTML pierde el foco. change : se produce cuando el valor del elemento HTML cambia (para < input >, < select > y < textarea >). keydown/keypress : se producen cuando el usuario presiona una tecla estando dentro del elemento HTML. Aunque realmente son eventos distintos, en la mayor\u00eda de las ocasiones se pueden considerar equivalentes. keyup : se produce cuando el usuario suelta una tecla estando dentro del elemento HTML. submit : se produce cuando se hace el submit de un formulario (para < form >). load : se produce cuando finaliza la carga del elemento HTML. T\u00edpicamente se utiliza para validar la carga del documento. unload : se produce cuando se descarga la p\u00e1gina (para < body >). error : se produce cuando se produce un error al cargar un fichero externo. A continuaci\u00f3n, pod\u00e9is ver un ejemplo ilustrativo de c\u00f3mo vincular c\u00f3digo JavaScript con alguno de estos eventos. El fichero eventos.html contiene el c\u00f3digo con el que se trabaja. Introducci\u00f3n a AJAX La clave de todo este proceso de llamadas as\u00edncronas en segundo plano al servidor es el objeto XMLHttpRequest* . Al tratarse de un objeto JavaScript*, la sintaxis para crearlo dentro de nuestro c\u00f3digo JS es: xmlhttp=new XMLHttpRequest(); Una vez instanciado, ofrece dos m\u00e9todos para hacer una petici\u00f3n al servidor: open(tipo, url, as\u00edncrona) : Permite configurar los datos de la petici\u00f3n. En cierta medida, podemos considerar que la configuraci\u00f3n de la llamada es an\u00e1loga a la especificaci\u00f3n de los datos de env\u00edo de un formulario en el documento HTML. El tipo de petici\u00f3n (atributo type del elemento < form >) podr\u00e1 ser \"GET\" o \"POST\". En el par\u00e1metro url indicaremos la url del servicio encargado de procesar la petici\u00f3n en el servidor (atributo action del elemento < form >). Y el tercer par\u00e1metro, sin equivalencia en el caso de un formulario en el que las peticiones al servidor conllevan la carga s\u00edncrona de un nuevo documento, es el indicador de si la petici\u00f3n debe procesarse de forma as\u00edncrona ( true ) o s\u00edncrona ( false ). Cuidado que es un indicador de asincronismo, no de sincronismo, lo que en ocasiones suele inducir a error a los desarrolladores. send([query_string]) Realiza el env\u00edo de la petici\u00f3n al servidor . Si no se le pasan par\u00e1metros, se realiza una petici\u00f3n GET en la que los par\u00e1metros de la llamada se han debido informar como query string en la url indicada en la llamada al m\u00e9todo open . Para peticiones POST, el m\u00e9todo send recibe un query string con los par\u00e1metros que enviar al servidor (p.ej., \"param1=valor1&param2=valor2\"). En este \u00faltimo caso, para que los par\u00e1metros se env\u00eden en la cabecera HTTP en lugar de en la URL, adicionalmente se debe incluir la siguiente l\u00ednea antes del env\u00edo: xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); As\u00ed, para realizar una petici\u00f3n GET as\u00edncrona que descargue la p\u00e1gina de acceso al sitio web de la Universidad Aut\u00f3noma de Madrid, har\u00edamos lo siguiente: xmlhttp = new XMLHttpRequest();xmlhttp.open(\"GET\",\"http://www.uam.com\",true);xmlhttp.send(); jQuery $(selector).accion() $(\"div#contenedor_lista input:checked\").parent().hide() $(document).ready(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Esto se utiliza tan habitualmente que incluso existe una sintaxis abreviada para asignar funcionalidad al evento ready() del document . Lo siguiente es completamente equivalente a la asignaci\u00f3n est\u00e1ndar: $(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Para reforzar los conocimientos adquiridos durante la lecci\u00f3n 2, le recomendamos visitar los siguientes sitios: P\u00e1gina del gestor de paquetes que incluye Python https://pypi.org https://realpython.com/what-is-pip/ https://realpython.com/pipenv-guide/ https://docs.scipy.org/doc/numpy-1.14.5/reference/ https://matplotlib.org https://www.edureka.co/blog/python-libraries/ https://packaging.python.org/tutorials/installing-packages/ https://packaging.python.org/tutorials/packaging-projects/ https://numpy.org/doc/stable/user/quickstart.html https://numpy.org/doc/stable/user/absolute_beginners.html https://www.geeksforgeeks.org/ init -in-python/ https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://es.wikipedia.org/wiki/Clase_(inform\u00e1tica) https://es.wikipedia.org/wiki/Instancia_(inform\u00e1tica) https://es.wikipedia.org/wiki/Constructor_(inform\u00e1tica) https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://www.programiz.com/python-programming/matrix https://matrix.reshish.com/es/multiplication.php https://realpython.com/python-modules-packages/#python-modules-overview https://www.geeksforgeeks.org/python-classes-and-objects/ Python Modules and Packages \u2013 An Introduction \u2013 Real Python Python packages: How to create and import them? Python Tutorial Python pip Python PIP Tutorial pandas: powerful Python data analysis toolkit numpy \u00b7 PyPI El Ingeniero Gonz\u00e1lez en cada video iba mostrando y explicando c\u00f3digo de Python, lo mas recomendable es que usted vaya replicando el mismo. A continuaci\u00f3n se comparte el c\u00f3digo que se utiliz\u00f3 y explic\u00f3 en los videos de lecci\u00f3n 5 (es importante que usted ya haya instalado Python para correr este c\u00f3digo): Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Importante: el c\u00f3digo fue creado siguiendo el siguiente formato: PrintX_DIAPOSITIVAY_PZ Donde X es el orden del programa en cuanto a que momento se utiliza, Y es la diapositiva donde se usa y Z la presentaci\u00f3n.","title":"Js"},{"location":"web/js/#js","text":"","title":"js"},{"location":"web/js/#estructuras-de-control","text":"C\u00f3digo Denominaci\u00f3n if(condici\u00f3n) { c\u00f3digo true }else { c\u00f3digo false} Estructura de control condicional (condici\u00f3n) ? valor_true : valor_false Operador de control condicional switch(expresi\u00f3n) { case condici\u00f3n_1: c\u00f3digo condici\u00f3n_1 [break;] \u2026 case condici\u00f3n_n: c\u00f3digo condici\u00f3n_n [break;] default: c\u00f3digo default} Estructura de control condicional basada en la evaluaci\u00f3n del valor de una expresi\u00f3n for(ini; condici\u00f3n; actualizaci\u00f3n){ c\u00f3digo bucle} Bucle condicional while(condici\u00f3n) { c\u00f3digo bucle} Bucle incondicional do { c\u00f3digo bucle} while(condicion) Bucle incondicional break Salida de un bloque de c\u00f3digo continue Parada de la ejecuci\u00f3n de un bucle para volver a evaluar la condici\u00f3n de parada try { c\u00f3digo js}catch(err) { c\u00f3digo que gestiona el error}finally { c\u00f3digo a ejecutar haya o no error} Captura y gesti\u00f3n de errores en el c\u00f3digo","title":"Estructuras de control"},{"location":"web/js/#operadores","text":"Operador Denominaci\u00f3n = Asignaci\u00f3n +, -, \\*, /, % Operadores aritm\u00e9ticos (act\u00faan sobre valores num\u00e9ricos) ++, -- Incremento, decremento **+=, -=, \\*=, /=, %=** Operaci\u00f3n aritm\u00e9tica + Asignaci\u00f3n +, += Concatenaci\u00f3n de Strings ==, !=, >, <, >=, <= Comparadores de valor **===** (igual valor e igual tipo)**!==** (distinto valor y distinto tipo) Comparadores de valor y tipo &&, ||, ! Operadores l\u00f3gicos < html > < head > < script > var a = 3 ; function mostrarVariable ( valor ) { alert ( valor ); // Aqu\u00ed mostramos el valor que recibe como par\u00e1metro alert ( a ); // Aqu\u00ed, el valor de la variable global } </ script > </ head > < body > Ejemplo sencillo de uso de < i > JavaScript </ i > < input type = \"button\" value = \"Pulsar...\" onclick = \"mostrarVariable(a)\" /> < script > alert ( a ); a = 5 ; </ script > </ body > </ html > La secuencia de acciones realizadas por el int\u00e9rprete JavaScript al interpretar este c\u00f3digo es: Crear una variable a y asignarle el valor num\u00e9rico 3.* * Crear una funci\u00f3n mostrarVariable que queda a la espera de ser invocada. Invocar a la funci\u00f3n alert para mostrar el valor actual de a . Cambiar el valor de a asign\u00e1ndole el valor num\u00e9rico 5. \u00bfCu\u00e1ndo se invoca la funci\u00f3n que hemos creado? En este caso, al pulsar el bot\u00f3n que hemos a\u00f1adido en el cuerpo del documento. Para ello utilizamos su atributo onclick , en el que se indica el c\u00f3digo JavaScript a ejecutar al \"hacer clic\" sobre el elemento. Lo que en realidad estamos haciendo con esa definici\u00f3n es asociar una funcionalidad a un evento, pero de momento no debes preocuparte por ello, en las siguientes secciones trataremos los eventos HTML en detalle.","title":"Operadores"},{"location":"web/js/#eventos","text":"Estos son algunos de los eventos HTML que m\u00e1s habitualmente se procesan en las aplicaciones web. Aunque procesando estos eventos podr\u00edas desarrollar cualquier aplicaci\u00f3n web t\u00edpica, como ya sabes, puedes encontrar la lista completa de eventos HTML en la documentaci\u00f3n de referencia de la W3C . Recuerda que para procesar un evento tienes que dar valor a la propiedad correspondiente en el elemento HTML, por ejemplo, para procesar el evento click debes fijar la propiedad onclick : click : se produce cuando el usuario hace click sobre el elemento HTML. mouseover : se produce cuando el usuario entra con el rat\u00f3n dentro del elemento HTML. mouseout : se produce cuando el usuario sale con el rat\u00f3n del elemento HTML. focus : se produce cuando el elemento HTML recibe el foco. blur : se produce cuando el elemento HTML pierde el foco. change : se produce cuando el valor del elemento HTML cambia (para < input >, < select > y < textarea >). keydown/keypress : se producen cuando el usuario presiona una tecla estando dentro del elemento HTML. Aunque realmente son eventos distintos, en la mayor\u00eda de las ocasiones se pueden considerar equivalentes. keyup : se produce cuando el usuario suelta una tecla estando dentro del elemento HTML. submit : se produce cuando se hace el submit de un formulario (para < form >). load : se produce cuando finaliza la carga del elemento HTML. T\u00edpicamente se utiliza para validar la carga del documento. unload : se produce cuando se descarga la p\u00e1gina (para < body >). error : se produce cuando se produce un error al cargar un fichero externo. A continuaci\u00f3n, pod\u00e9is ver un ejemplo ilustrativo de c\u00f3mo vincular c\u00f3digo JavaScript con alguno de estos eventos. El fichero eventos.html contiene el c\u00f3digo con el que se trabaja.","title":"eventos"},{"location":"web/js/#introduccion-a-ajax","text":"La clave de todo este proceso de llamadas as\u00edncronas en segundo plano al servidor es el objeto XMLHttpRequest* . Al tratarse de un objeto JavaScript*, la sintaxis para crearlo dentro de nuestro c\u00f3digo JS es: xmlhttp=new XMLHttpRequest(); Una vez instanciado, ofrece dos m\u00e9todos para hacer una petici\u00f3n al servidor: open(tipo, url, as\u00edncrona) : Permite configurar los datos de la petici\u00f3n. En cierta medida, podemos considerar que la configuraci\u00f3n de la llamada es an\u00e1loga a la especificaci\u00f3n de los datos de env\u00edo de un formulario en el documento HTML. El tipo de petici\u00f3n (atributo type del elemento < form >) podr\u00e1 ser \"GET\" o \"POST\". En el par\u00e1metro url indicaremos la url del servicio encargado de procesar la petici\u00f3n en el servidor (atributo action del elemento < form >). Y el tercer par\u00e1metro, sin equivalencia en el caso de un formulario en el que las peticiones al servidor conllevan la carga s\u00edncrona de un nuevo documento, es el indicador de si la petici\u00f3n debe procesarse de forma as\u00edncrona ( true ) o s\u00edncrona ( false ). Cuidado que es un indicador de asincronismo, no de sincronismo, lo que en ocasiones suele inducir a error a los desarrolladores. send([query_string]) Realiza el env\u00edo de la petici\u00f3n al servidor . Si no se le pasan par\u00e1metros, se realiza una petici\u00f3n GET en la que los par\u00e1metros de la llamada se han debido informar como query string en la url indicada en la llamada al m\u00e9todo open . Para peticiones POST, el m\u00e9todo send recibe un query string con los par\u00e1metros que enviar al servidor (p.ej., \"param1=valor1&param2=valor2\"). En este \u00faltimo caso, para que los par\u00e1metros se env\u00eden en la cabecera HTTP en lugar de en la URL, adicionalmente se debe incluir la siguiente l\u00ednea antes del env\u00edo: xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); As\u00ed, para realizar una petici\u00f3n GET as\u00edncrona que descargue la p\u00e1gina de acceso al sitio web de la Universidad Aut\u00f3noma de Madrid, har\u00edamos lo siguiente: xmlhttp = new XMLHttpRequest();xmlhttp.open(\"GET\",\"http://www.uam.com\",true);xmlhttp.send();","title":"Introducci\u00f3n a AJAX"},{"location":"web/js/#jquery","text":"$(selector).accion() $(\"div#contenedor_lista input:checked\").parent().hide() $(document).ready(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Esto se utiliza tan habitualmente que incluso existe una sintaxis abreviada para asignar funcionalidad al evento ready() del document . Lo siguiente es completamente equivalente a la asignaci\u00f3n est\u00e1ndar: $(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Para reforzar los conocimientos adquiridos durante la lecci\u00f3n 2, le recomendamos visitar los siguientes sitios: P\u00e1gina del gestor de paquetes que incluye Python https://pypi.org https://realpython.com/what-is-pip/ https://realpython.com/pipenv-guide/ https://docs.scipy.org/doc/numpy-1.14.5/reference/ https://matplotlib.org https://www.edureka.co/blog/python-libraries/ https://packaging.python.org/tutorials/installing-packages/ https://packaging.python.org/tutorials/packaging-projects/ https://numpy.org/doc/stable/user/quickstart.html https://numpy.org/doc/stable/user/absolute_beginners.html https://www.geeksforgeeks.org/ init -in-python/ https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://es.wikipedia.org/wiki/Clase_(inform\u00e1tica) https://es.wikipedia.org/wiki/Instancia_(inform\u00e1tica) https://es.wikipedia.org/wiki/Constructor_(inform\u00e1tica) https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://www.programiz.com/python-programming/matrix https://matrix.reshish.com/es/multiplication.php https://realpython.com/python-modules-packages/#python-modules-overview https://www.geeksforgeeks.org/python-classes-and-objects/ Python Modules and Packages \u2013 An Introduction \u2013 Real Python Python packages: How to create and import them? Python Tutorial Python pip Python PIP Tutorial pandas: powerful Python data analysis toolkit numpy \u00b7 PyPI El Ingeniero Gonz\u00e1lez en cada video iba mostrando y explicando c\u00f3digo de Python, lo mas recomendable es que usted vaya replicando el mismo. A continuaci\u00f3n se comparte el c\u00f3digo que se utiliz\u00f3 y explic\u00f3 en los videos de lecci\u00f3n 5 (es importante que usted ya haya instalado Python para correr este c\u00f3digo): Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Importante: el c\u00f3digo fue creado siguiendo el siguiente formato: PrintX_DIAPOSITIVAY_PZ Donde X es el orden del programa en cuanto a que momento se utiliza, Y es la diapositiva donde se usa y Z la presentaci\u00f3n.","title":"jQuery"},{"location":"web/py/","text":"py links Introduction to Python: Absolute Beginner (edX). Introducci\u00f3n al desarrollo de aplicaciones web (edx) ** de aqui es la documentacion Curso de Python B\u00e1sico Gratis (Web C\u00f3digo Facilito). venv requirements.txt flask pk@pk:~$ type vvvv vvvv () { deactivate ; python3.8 -m venv ./.venv ; source ./.venv/bin/activate ; pip install -r requirements.txt ; python app.py } pk@pk:~$ pk@pk:~$ flask app.py import sys from flask import Flask , request app = Flask ( __name__ ) @app . route ( '/' ) def index (): user_agent = request . headers . get ( 'User-Agent' ) return '<p>Your browser is %s </p>' % user_agent @app . route ( '/processLogin' , methods = [ 'POST' ]) def process_login (): missing = [] fields = [ 'email' , 'passwd' , 'login_submit' ] for field in fields : value = request . form . get ( field , None ) if value is None : missing . append ( field ) if missing : return \"Warning: Some fields are missing\" return '<!DOCTYPE html> ' \\ '<html lang=\"es\">' \\ '<head>' \\ '<link href=\"static/css/my-socnet-style.css\" rel=\"stylesheet\" type=\"text/css\"/>' \\ '<title> Home - SocNet </title>' \\ '</head>' \\ '<body> <div id =\"container\">' \\ '<a href=\"/\"> SocNet </a> | <a href=\"home\"> Home </a> | <a href=\"login\"> Log In </a> | <a href=\"signup\"> Sign Up </a>' \\ '<h1>Data from Form: Login</h1>' \\ '<form><label>email: ' + request . form [ 'email' ] + \\ '</label><br><label>passwd: ' + request . form [ 'passwd' ] + \\ '</label></form></div></body>' \\ '</html>' if __name__ == '__main__' : if sys . platform == 'ubuntu' : app . run ( debug = True , port = 8080 ) else : app . run ( debug = True , port = 80 ) index.html json Las estructuras de JSON tienen una traducci\u00f3n directa a estructuras Python: Los objetos JSON son representados como diccionarios en Python Los arrays JSON son representados como listas en Python true y false en JSON son valores del tipo boolean en Python Las cadenas en JSON son cadenas en Python Los n\u00fameros en JSON son float o integer , seg\u00fan corresponda, en Python Por este motivo, las funciones para leer y escribir ficheros JSON son muy sencillas de utilizar. En ambos casos recurrimos a la biblioteca JSON, as\u00ed que lo primero que debemos hacer es: import json Lectura La funci\u00f3n para leer un fichero JSON es json.load. Como par\u00e1metro un fichero, as\u00ed que una forma normal de usarla es: with open(\u201cnombre_fichero.json\u201d, 'r') as f: data = json.load(f) Despu\u00e9s de ejecutar esto, la variable data contendr\u00e1 un diccionario con los datos cargados del fichero. Si por ejemplo hubi\u00e9ramos cargado el fichero con los datos del usuario James visto en la secci\u00f3n anterior, ahora data[\u2018user_name\u2019] ser\u00eda \u201cJames\u201d y data[\u2018messages\u2019] ser\u00eda una lista Python con los mensajes publicados por James. Escritura Volcar una estructura Python a un fichero JSON es igual de sencillo. Supongamos que tenemos la siguiente inicializaci\u00f3n de la variable datos: datos = { \"user_name\": \"James\", \"password\": \u201c007\u201d, \"messages\": [(1532648502.113984, \u201cmensaje 1\u201d), (1532648642.729385, \u201cmensaje 1\u201d)], \"email\": session['email'], \"friends\": session['friends']} Entonces guardar los datos en el fichero correspondiente ser\u00eda: with open(\u201cjames.bond@mi6.uk\u201d, 'w') as f: json.dump(datos, f) sesiones Ya hemos dicho en varias oportunidades que el protocolo HTTP no tiene estado, que no recuerda. \u00bfQu\u00e9 significa eso en la pr\u00e1ctica? Que necesitamos informaci\u00f3n adicional para implementar una \u201cconversaci\u00f3n\u201d entre cliente y servidor. Esta idea de conversaci\u00f3n, donde ambas partes recuerdan lo que han hablado hasta el momento, se llama sesi\u00f3n . Aunque el concepto o la duraci\u00f3n de una sesi\u00f3n puede variar en distintos entornos, b\u00e1sicamente es el conjunto de interacciones entre cliente y servidor en un lapso de tiempo razonable. La primera vez que un cliente realiza una petici\u00f3n, despu\u00e9s de un tiempo sin interactuar, el servidor abre una sesi\u00f3n . Las subsecuentes peticiones desde ese cliente se consideran dentro de la misma sesi\u00f3n. Si pasa mucho tiempo sin que el cliente realice una petici\u00f3n, el servidor asume que ya no est\u00e1 conectado y termina la sesi\u00f3n. La biblioteca Flask nos ofrece este concepto de sesi\u00f3n. Pero si HTTP no tiene informaci\u00f3n espec\u00edfica que permita identificar al usuario o la sesi\u00f3n, \u00bfc\u00f3mo sabe Flask a qu\u00e9 usuario corresponde una determinada petici\u00f3n? Existen al menos 3 formas de que una petici\u00f3n HTTP transporte informaci\u00f3n que permita identificar al usuario o la sesi\u00f3n: Cookies : las cookies son peque\u00f1os ficheros que se adjuntan a una respuesta HTTP, con informaci\u00f3n de identificaci\u00f3n de usuario. En sucesivas peticiones HTTP, el navegador incluye ese fichero autom\u00e1ticamente, por lo que el servidor podr\u00e1 tener la identificaci\u00f3n de ese usuario. Campos ocultos : en los formularios que el servidor env\u00eda a cliente para que sean completados, incluyo un campo del tipo input que no se muestra al usuario; ese campo lleva informaci\u00f3n que cuando los datos del formulario se env\u00eden de vuelta al servidor le servir\u00e1 para identificar al cliente. Reescritura de URLs : aunque nos parezcan iguales, el servidor introduce autom\u00e1ticamente peque\u00f1as modificaciones a las URLs; de esta forma, la URL espec\u00edfica que solicite permitir\u00e1 al servidor identificar al cliente. La buena noticia es que, generalmente, el mecanismo que se use para transportar la informaci\u00f3n de sesi\u00f3n no es visible al desarrollador de la aplicaci\u00f3n web. Esto es exactamente lo que ocurre con el soporte de sesiones que nos ofrece Flask, y que veremos a continuaci\u00f3n. Vamos a ver c\u00f3mo podemos manejar una sesi\u00f3n en Python y Flask para poder almacenar informaci\u00f3n entre cada una de las peticiones que el cliente haga al servidor. Objeto Flask Session El objeto que nos guarda la informaci\u00f3n entre sesiones se llama session. Lo primero ser\u00e1 importarlo dentro de nuestro c\u00f3digo Python para luego poder usarlo: from flask import Flask, session Como la informaci\u00f3n de la sesi\u00f3n viaja del servidor al cliente ida y vuelta, es importante que nadie en el camino, ni siquiera el propio cliente, puedan alterar esa informaci\u00f3n. En particular, se debe evitar que alguien de fuera \u201ctome control\u201d de la sesi\u00f3n. En seguridad inform\u00e1tica, este tipo de ataque se conoce como CSRF (Cross-site request forgery) o robo de sesi\u00f3n. Para asegurarse que eso no ocurre, Flask utiliza t\u00e9cnicas de encriptaci\u00f3n para proteger la informaci\u00f3n. Para eso, necesita una clav de encriptaci\u00f3n/desencriptaci\u00f3n. Esta clave, que s\u00f3lo debe conocer el servidor y que debe ser distinta para todos los programas servidor, se crea en el propio c\u00f3digo del servidor. Por ejemplo: app.secret_key = 'esto-es-una-clave-muy-secreta' De hecho, en el c\u00f3digo de nuestra aplicaci\u00f3n SocNet habr\u00e1s visto una l\u00ednea similar a esta: app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' Ahora ya sabes para qu\u00e9 sirve. Si quieres tener m\u00e1s informaci\u00f3n de este problema de seguridad inform\u00e1tica y su soluci\u00f3n, puedes leer aqu\u00ed . Ahora vamos a ver ejemplo de c\u00f3mo utilizamos las sesiones en nuestra aplicaci\u00f3n favorita. La primera funci\u00f3n, *load_user(email, passwd)* , intenta cargar los datos desde un fichero. Importante : aqu\u00ed almacenamos los datos en un fichero por una cuesti\u00f3n de simplicidad. En aplicaciones con cientos o miles de usuarios lo normal es almacenar los datos en una base de datos propiamente dicha. Si el fichero existe, carga los datos y a continuaci\u00f3n comprueba que la clave suministrada coincida con la que est\u00e1 almacenada. Nota de seguridad : otra vez, para facilitar las explicaciones y la comprensi\u00f3n de los conceptos b\u00e1sicos, realizamos algunas simplificaciones que antes de hacer p\u00fablico un sistema deben ser corregidas. Por ejemplo, nunca se debe guardar una clave de usuario \u201cen claro\u201d, siempre se debe hacer codificada con alg\u00fan algoritmo como por ejemplo SHA-256. Lamentable estas cuestiones quedan fuera del \u00e1mbito de este curso. Si todas las condiciones son correctas, la funci\u00f3n guarda los datos relevantes del usuario (nombre, mensajes que ha escrito hasta el momento, la clave, su correo electr\u00f3nico y la lista de amigos) en la sesi\u00f3n , para que est\u00e9n disponibles para las pr\u00f3xima llamadas desde el cliente. def load_user ( email , passwd ): \"\"\" It loads data for the given user (identified by email) from the data directory. It looks for a file whose name matches the user email :param email: user id :param passwd: password to check in order to validate the user :return: content of the home page (app basic page) if user exists and password is correct \"\"\" file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if not os . path . isfile ( file_path ): return process_error ( \"User not found / No existe un usuario con ese nombre\" , url_for ( \"login\" )) with open ( file_path , 'r' ) as f : data = json . load ( f ) if data [ 'password' ] != passwd : return process_error ( \"Incorrect password / la clave no es correcta\" , url_for ( \"login\" )) session [ 'user_name' ] = data [ 'user_name' ] session [ 'messages' ] = data [ 'messages' ] session [ 'password' ] = passwd session [ 'email' ] = email session [ 'friends' ] = data [ 'friends' ] return redirect ( url_for ( \"home\" )) De la misma forma, cuando un usuario quiere salir del sistema, debemos guardar los datos en el fichero (base de datos) para que est\u00e9n disponibles la pr\u00f3xima vez que el usuario vuelva a nuestra aplicaci\u00f3n. Este es el objetivo de la funci\u00f3n save_current_user() , que vuelca los datos de session en el fichero correspondiente. Por otra parte, cuando un usuario se da de alta, se debe crear el fichero, previa comprobaci\u00f3n que no exista un usuario con el mismo identificador (correo electr\u00f3nico). Esto es lo que hace la funci\u00f3n create_user_file(name, email, passwd, passwd_confirmation) . def save_current_user (): datos = { \"user_name\" : session [ \"user_name\" ], \"password\" : session [ 'password' ], \"messages\" : session [ 'messages' ], # lista de tuplas (time_stamp, mensaje) \"email\" : session [ 'email' ], \"friends\" : session [ 'friends' ] } file_path = os . path . join ( SITE_ROOT , \"data/\" , session [ 'email' ]) with open ( file_path , 'w' ) as f : json . dump ( datos , f ) def create_user_file ( name , email , passwd , passwd_confirmation ): \"\"\" It creates the file (in the /data directory) for storing user data. The file name will match the user email. If the file already exists, it returns an error. If the password does not match the confirmation, it returns an error. :param name: Name or nickname of the user :param email: user email, which will be later used for retrieving data :param passwd: password for future logins :param passwd_confirmation: confirmation, must match the password :return: if no error is found, it sends the user to the home page \"\"\" directory = os . path . join ( SITE_ROOT , \"data\" ) if not os . path . exists ( directory ): os . makedirs ( directory ) file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if os . path . isfile ( file_path ): return process_error ( \"The email is already used, you must select a different email / Ya existe un usuario con ese nombre\" , url_for ( \"signup\" )) if passwd != passwd_confirmation : return process_error ( \"Your password and confirmation password do not match / Las claves no coinciden\" , url_for ( \"signup\" )) datos = { \"user_name\" : name , \"password\" : passwd , \"messages\" : [], \"friends\" : [] } with open ( file_path , 'w' ) as f : json . dump ( datos , f ) session [ 'user_name' ] = name session [ 'password' ] = passwd session [ 'messages' ] = [] session [ 'friends' ] = [] session [ 'email' ] = email return redirect ( url_for ( \"home\" ))","title":"py"},{"location":"web/py/#py","text":"","title":"py"},{"location":"web/py/#links","text":"Introduction to Python: Absolute Beginner (edX). Introducci\u00f3n al desarrollo de aplicaciones web (edx) ** de aqui es la documentacion Curso de Python B\u00e1sico Gratis (Web C\u00f3digo Facilito).","title":"links"},{"location":"web/py/#venv","text":"requirements.txt flask pk@pk:~$ type vvvv vvvv () { deactivate ; python3.8 -m venv ./.venv ; source ./.venv/bin/activate ; pip install -r requirements.txt ; python app.py } pk@pk:~$ pk@pk:~$","title":"venv"},{"location":"web/py/#flask","text":"app.py import sys from flask import Flask , request app = Flask ( __name__ ) @app . route ( '/' ) def index (): user_agent = request . headers . get ( 'User-Agent' ) return '<p>Your browser is %s </p>' % user_agent @app . route ( '/processLogin' , methods = [ 'POST' ]) def process_login (): missing = [] fields = [ 'email' , 'passwd' , 'login_submit' ] for field in fields : value = request . form . get ( field , None ) if value is None : missing . append ( field ) if missing : return \"Warning: Some fields are missing\" return '<!DOCTYPE html> ' \\ '<html lang=\"es\">' \\ '<head>' \\ '<link href=\"static/css/my-socnet-style.css\" rel=\"stylesheet\" type=\"text/css\"/>' \\ '<title> Home - SocNet </title>' \\ '</head>' \\ '<body> <div id =\"container\">' \\ '<a href=\"/\"> SocNet </a> | <a href=\"home\"> Home </a> | <a href=\"login\"> Log In </a> | <a href=\"signup\"> Sign Up </a>' \\ '<h1>Data from Form: Login</h1>' \\ '<form><label>email: ' + request . form [ 'email' ] + \\ '</label><br><label>passwd: ' + request . form [ 'passwd' ] + \\ '</label></form></div></body>' \\ '</html>' if __name__ == '__main__' : if sys . platform == 'ubuntu' : app . run ( debug = True , port = 8080 ) else : app . run ( debug = True , port = 80 ) index.html","title":"flask"},{"location":"web/py/#json","text":"Las estructuras de JSON tienen una traducci\u00f3n directa a estructuras Python: Los objetos JSON son representados como diccionarios en Python Los arrays JSON son representados como listas en Python true y false en JSON son valores del tipo boolean en Python Las cadenas en JSON son cadenas en Python Los n\u00fameros en JSON son float o integer , seg\u00fan corresponda, en Python Por este motivo, las funciones para leer y escribir ficheros JSON son muy sencillas de utilizar. En ambos casos recurrimos a la biblioteca JSON, as\u00ed que lo primero que debemos hacer es: import json","title":"json"},{"location":"web/py/#lectura","text":"La funci\u00f3n para leer un fichero JSON es json.load. Como par\u00e1metro un fichero, as\u00ed que una forma normal de usarla es: with open(\u201cnombre_fichero.json\u201d, 'r') as f: data = json.load(f) Despu\u00e9s de ejecutar esto, la variable data contendr\u00e1 un diccionario con los datos cargados del fichero. Si por ejemplo hubi\u00e9ramos cargado el fichero con los datos del usuario James visto en la secci\u00f3n anterior, ahora data[\u2018user_name\u2019] ser\u00eda \u201cJames\u201d y data[\u2018messages\u2019] ser\u00eda una lista Python con los mensajes publicados por James.","title":"Lectura"},{"location":"web/py/#escritura","text":"Volcar una estructura Python a un fichero JSON es igual de sencillo. Supongamos que tenemos la siguiente inicializaci\u00f3n de la variable datos: datos = { \"user_name\": \"James\", \"password\": \u201c007\u201d, \"messages\": [(1532648502.113984, \u201cmensaje 1\u201d), (1532648642.729385, \u201cmensaje 1\u201d)], \"email\": session['email'], \"friends\": session['friends']} Entonces guardar los datos en el fichero correspondiente ser\u00eda: with open(\u201cjames.bond@mi6.uk\u201d, 'w') as f: json.dump(datos, f)","title":"Escritura"},{"location":"web/py/#sesiones","text":"Ya hemos dicho en varias oportunidades que el protocolo HTTP no tiene estado, que no recuerda. \u00bfQu\u00e9 significa eso en la pr\u00e1ctica? Que necesitamos informaci\u00f3n adicional para implementar una \u201cconversaci\u00f3n\u201d entre cliente y servidor. Esta idea de conversaci\u00f3n, donde ambas partes recuerdan lo que han hablado hasta el momento, se llama sesi\u00f3n . Aunque el concepto o la duraci\u00f3n de una sesi\u00f3n puede variar en distintos entornos, b\u00e1sicamente es el conjunto de interacciones entre cliente y servidor en un lapso de tiempo razonable. La primera vez que un cliente realiza una petici\u00f3n, despu\u00e9s de un tiempo sin interactuar, el servidor abre una sesi\u00f3n . Las subsecuentes peticiones desde ese cliente se consideran dentro de la misma sesi\u00f3n. Si pasa mucho tiempo sin que el cliente realice una petici\u00f3n, el servidor asume que ya no est\u00e1 conectado y termina la sesi\u00f3n. La biblioteca Flask nos ofrece este concepto de sesi\u00f3n. Pero si HTTP no tiene informaci\u00f3n espec\u00edfica que permita identificar al usuario o la sesi\u00f3n, \u00bfc\u00f3mo sabe Flask a qu\u00e9 usuario corresponde una determinada petici\u00f3n? Existen al menos 3 formas de que una petici\u00f3n HTTP transporte informaci\u00f3n que permita identificar al usuario o la sesi\u00f3n: Cookies : las cookies son peque\u00f1os ficheros que se adjuntan a una respuesta HTTP, con informaci\u00f3n de identificaci\u00f3n de usuario. En sucesivas peticiones HTTP, el navegador incluye ese fichero autom\u00e1ticamente, por lo que el servidor podr\u00e1 tener la identificaci\u00f3n de ese usuario. Campos ocultos : en los formularios que el servidor env\u00eda a cliente para que sean completados, incluyo un campo del tipo input que no se muestra al usuario; ese campo lleva informaci\u00f3n que cuando los datos del formulario se env\u00eden de vuelta al servidor le servir\u00e1 para identificar al cliente. Reescritura de URLs : aunque nos parezcan iguales, el servidor introduce autom\u00e1ticamente peque\u00f1as modificaciones a las URLs; de esta forma, la URL espec\u00edfica que solicite permitir\u00e1 al servidor identificar al cliente. La buena noticia es que, generalmente, el mecanismo que se use para transportar la informaci\u00f3n de sesi\u00f3n no es visible al desarrollador de la aplicaci\u00f3n web. Esto es exactamente lo que ocurre con el soporte de sesiones que nos ofrece Flask, y que veremos a continuaci\u00f3n. Vamos a ver c\u00f3mo podemos manejar una sesi\u00f3n en Python y Flask para poder almacenar informaci\u00f3n entre cada una de las peticiones que el cliente haga al servidor.","title":"sesiones"},{"location":"web/py/#objeto-flask-session","text":"El objeto que nos guarda la informaci\u00f3n entre sesiones se llama session. Lo primero ser\u00e1 importarlo dentro de nuestro c\u00f3digo Python para luego poder usarlo: from flask import Flask, session Como la informaci\u00f3n de la sesi\u00f3n viaja del servidor al cliente ida y vuelta, es importante que nadie en el camino, ni siquiera el propio cliente, puedan alterar esa informaci\u00f3n. En particular, se debe evitar que alguien de fuera \u201ctome control\u201d de la sesi\u00f3n. En seguridad inform\u00e1tica, este tipo de ataque se conoce como CSRF (Cross-site request forgery) o robo de sesi\u00f3n. Para asegurarse que eso no ocurre, Flask utiliza t\u00e9cnicas de encriptaci\u00f3n para proteger la informaci\u00f3n. Para eso, necesita una clav de encriptaci\u00f3n/desencriptaci\u00f3n. Esta clave, que s\u00f3lo debe conocer el servidor y que debe ser distinta para todos los programas servidor, se crea en el propio c\u00f3digo del servidor. Por ejemplo: app.secret_key = 'esto-es-una-clave-muy-secreta' De hecho, en el c\u00f3digo de nuestra aplicaci\u00f3n SocNet habr\u00e1s visto una l\u00ednea similar a esta: app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' Ahora ya sabes para qu\u00e9 sirve. Si quieres tener m\u00e1s informaci\u00f3n de este problema de seguridad inform\u00e1tica y su soluci\u00f3n, puedes leer aqu\u00ed . Ahora vamos a ver ejemplo de c\u00f3mo utilizamos las sesiones en nuestra aplicaci\u00f3n favorita. La primera funci\u00f3n, *load_user(email, passwd)* , intenta cargar los datos desde un fichero. Importante : aqu\u00ed almacenamos los datos en un fichero por una cuesti\u00f3n de simplicidad. En aplicaciones con cientos o miles de usuarios lo normal es almacenar los datos en una base de datos propiamente dicha. Si el fichero existe, carga los datos y a continuaci\u00f3n comprueba que la clave suministrada coincida con la que est\u00e1 almacenada. Nota de seguridad : otra vez, para facilitar las explicaciones y la comprensi\u00f3n de los conceptos b\u00e1sicos, realizamos algunas simplificaciones que antes de hacer p\u00fablico un sistema deben ser corregidas. Por ejemplo, nunca se debe guardar una clave de usuario \u201cen claro\u201d, siempre se debe hacer codificada con alg\u00fan algoritmo como por ejemplo SHA-256. Lamentable estas cuestiones quedan fuera del \u00e1mbito de este curso. Si todas las condiciones son correctas, la funci\u00f3n guarda los datos relevantes del usuario (nombre, mensajes que ha escrito hasta el momento, la clave, su correo electr\u00f3nico y la lista de amigos) en la sesi\u00f3n , para que est\u00e9n disponibles para las pr\u00f3xima llamadas desde el cliente. def load_user ( email , passwd ): \"\"\" It loads data for the given user (identified by email) from the data directory. It looks for a file whose name matches the user email :param email: user id :param passwd: password to check in order to validate the user :return: content of the home page (app basic page) if user exists and password is correct \"\"\" file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if not os . path . isfile ( file_path ): return process_error ( \"User not found / No existe un usuario con ese nombre\" , url_for ( \"login\" )) with open ( file_path , 'r' ) as f : data = json . load ( f ) if data [ 'password' ] != passwd : return process_error ( \"Incorrect password / la clave no es correcta\" , url_for ( \"login\" )) session [ 'user_name' ] = data [ 'user_name' ] session [ 'messages' ] = data [ 'messages' ] session [ 'password' ] = passwd session [ 'email' ] = email session [ 'friends' ] = data [ 'friends' ] return redirect ( url_for ( \"home\" )) De la misma forma, cuando un usuario quiere salir del sistema, debemos guardar los datos en el fichero (base de datos) para que est\u00e9n disponibles la pr\u00f3xima vez que el usuario vuelva a nuestra aplicaci\u00f3n. Este es el objetivo de la funci\u00f3n save_current_user() , que vuelca los datos de session en el fichero correspondiente. Por otra parte, cuando un usuario se da de alta, se debe crear el fichero, previa comprobaci\u00f3n que no exista un usuario con el mismo identificador (correo electr\u00f3nico). Esto es lo que hace la funci\u00f3n create_user_file(name, email, passwd, passwd_confirmation) . def save_current_user (): datos = { \"user_name\" : session [ \"user_name\" ], \"password\" : session [ 'password' ], \"messages\" : session [ 'messages' ], # lista de tuplas (time_stamp, mensaje) \"email\" : session [ 'email' ], \"friends\" : session [ 'friends' ] } file_path = os . path . join ( SITE_ROOT , \"data/\" , session [ 'email' ]) with open ( file_path , 'w' ) as f : json . dump ( datos , f ) def create_user_file ( name , email , passwd , passwd_confirmation ): \"\"\" It creates the file (in the /data directory) for storing user data. The file name will match the user email. If the file already exists, it returns an error. If the password does not match the confirmation, it returns an error. :param name: Name or nickname of the user :param email: user email, which will be later used for retrieving data :param passwd: password for future logins :param passwd_confirmation: confirmation, must match the password :return: if no error is found, it sends the user to the home page \"\"\" directory = os . path . join ( SITE_ROOT , \"data\" ) if not os . path . exists ( directory ): os . makedirs ( directory ) file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if os . path . isfile ( file_path ): return process_error ( \"The email is already used, you must select a different email / Ya existe un usuario con ese nombre\" , url_for ( \"signup\" )) if passwd != passwd_confirmation : return process_error ( \"Your password and confirmation password do not match / Las claves no coinciden\" , url_for ( \"signup\" )) datos = { \"user_name\" : name , \"password\" : passwd , \"messages\" : [], \"friends\" : [] } with open ( file_path , 'w' ) as f : json . dump ( datos , f ) session [ 'user_name' ] = name session [ 'password' ] = passwd session [ 'messages' ] = [] session [ 'friends' ] = [] session [ 'email' ] = email return redirect ( url_for ( \"home\" ))","title":"Objeto Flask Session"}]}