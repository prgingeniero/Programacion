{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programacion webscarpt Beautiful Soup Como se observ\u00f3 en esta unidad, BeautifulSoup toma el contenido de la p\u00e1gina web y lo interpreta generando una estructura m\u00e1s manejable. Si bien nos enfocaremos en las etiquetas principales, vale la pena mencionar los tipos de objetos producidos: Tag : es el objeto que nos interesa principalmente y corresponde a las etiquetas en el documento de HTML. ( documentaci\u00f3n ) NavigableString : esta cadena de texto representa el contenido dentro de una etiqueta. Tiene capacidades extras relacionadas con la navegaci\u00f3n dentro de la estructura. ( documentaci\u00f3n ) BeautifulSoup : este objeto representa el documento HTML interpretado como una estructura jer\u00e1rquica. Para fines convencionales, puede ser considerado como objeto de tipo tag, soportando los mismos tipos de m\u00e9todos. ( documentaci\u00f3n ) Comment : este objeto es un tipo especial de NavigatableString, que se representa con un formato especial al momento de impresi\u00f3n. En resumen, se ha descrito de forma general el funcionamiento del m\u00f3dulo de BeautifulSoup para, en conjunto de la herramiento de peticiones requests, interpretar la estructura de un documento HTML. En las siguientes unidades se expandir\u00e1 la informaci\u00f3n sobre las funciones, m\u00e9todos y atributos relacionados con la extracci\u00f3n de los datos de inter\u00e9s. Sin embargo, existen propiedades y capacidades que pueden resultar interesantes como elementos auxiliares en el \u00e1rbol generado, o notaciones abreviadas que sirven para crear un c\u00f3digo m\u00e1s compacto. Referencias : \u200b Reitz, K. (2020). Requests: HTTP for Humans. https://docs.python-requests.org/en/master/ Richardson, L. (2020). Beautiful Soup Documentation. https://www.crummy.com/software/BeautifulSoup/bs4/doc/ Iterando sobre los elementos en Beautiful Soup Hasta el momento se han visto dos principales maneras de c\u00f3mo se puede utilizar el \u00e1rbol jer\u00e1rquico producido por BeautifulSoup con base a una p\u00e1gina web: utilizando m\u00e9todos de b\u00fasqueda, y navegando manualmente por los elementos, cada uno con sus ventajas y desventajas. Sin embargo, podemos utilizar un enfoque intermedio entre estos dos extremos y es el de utilizar m\u00e9todos de iteraci\u00f3n sobre los elementos. De esta forma podemos tener la ventaja de la flexibilidad de la b\u00fasqueda, pero con el poder de ajustar la selecci\u00f3n de los elementos de forma manual. Para lograr este objetivo, BeautifulSoup cuenta con diferentes herramientas y m\u00e9todos,siendo uno de ellos el atributo \u201c descendants \u201d. Su comportamiento es similar al de \u201c children \u201d pero no solo se limita a los elementos inmediatos, si no que enlista todos los elementos, es decir, los hijos, los hijos de los hijos, etc.","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#webscarpt","text":"","title":"webscarpt"},{"location":"#beautiful-soup","text":"Como se observ\u00f3 en esta unidad, BeautifulSoup toma el contenido de la p\u00e1gina web y lo interpreta generando una estructura m\u00e1s manejable. Si bien nos enfocaremos en las etiquetas principales, vale la pena mencionar los tipos de objetos producidos: Tag : es el objeto que nos interesa principalmente y corresponde a las etiquetas en el documento de HTML. ( documentaci\u00f3n ) NavigableString : esta cadena de texto representa el contenido dentro de una etiqueta. Tiene capacidades extras relacionadas con la navegaci\u00f3n dentro de la estructura. ( documentaci\u00f3n ) BeautifulSoup : este objeto representa el documento HTML interpretado como una estructura jer\u00e1rquica. Para fines convencionales, puede ser considerado como objeto de tipo tag, soportando los mismos tipos de m\u00e9todos. ( documentaci\u00f3n ) Comment : este objeto es un tipo especial de NavigatableString, que se representa con un formato especial al momento de impresi\u00f3n. En resumen, se ha descrito de forma general el funcionamiento del m\u00f3dulo de BeautifulSoup para, en conjunto de la herramiento de peticiones requests, interpretar la estructura de un documento HTML. En las siguientes unidades se expandir\u00e1 la informaci\u00f3n sobre las funciones, m\u00e9todos y atributos relacionados con la extracci\u00f3n de los datos de inter\u00e9s. Sin embargo, existen propiedades y capacidades que pueden resultar interesantes como elementos auxiliares en el \u00e1rbol generado, o notaciones abreviadas que sirven para crear un c\u00f3digo m\u00e1s compacto. Referencias : \u200b Reitz, K. (2020). Requests: HTTP for Humans. https://docs.python-requests.org/en/master/ Richardson, L. (2020). Beautiful Soup Documentation. https://www.crummy.com/software/BeautifulSoup/bs4/doc/","title":"Beautiful Soup"},{"location":"#iterando-sobre-los-elementos-en-beautiful-soup","text":"Hasta el momento se han visto dos principales maneras de c\u00f3mo se puede utilizar el \u00e1rbol jer\u00e1rquico producido por BeautifulSoup con base a una p\u00e1gina web: utilizando m\u00e9todos de b\u00fasqueda, y navegando manualmente por los elementos, cada uno con sus ventajas y desventajas. Sin embargo, podemos utilizar un enfoque intermedio entre estos dos extremos y es el de utilizar m\u00e9todos de iteraci\u00f3n sobre los elementos. De esta forma podemos tener la ventaja de la flexibilidad de la b\u00fasqueda, pero con el poder de ajustar la selecci\u00f3n de los elementos de forma manual. Para lograr este objetivo, BeautifulSoup cuenta con diferentes herramientas y m\u00e9todos,siendo uno de ellos el atributo \u201c descendants \u201d. Su comportamiento es similar al de \u201c children \u201d pero no solo se limita a los elementos inmediatos, si no que enlista todos los elementos, es decir, los hijos, los hijos de los hijos, etc.","title":"Iterando sobre los elementos en Beautiful Soup"},{"location":"web/js/","text":"js Estructuras de control C\u00f3digo Denominaci\u00f3n if(condici\u00f3n) { c\u00f3digo true }else { c\u00f3digo false} Estructura de control condicional (condici\u00f3n) ? valor_true : valor_false Operador de control condicional switch(expresi\u00f3n) { case condici\u00f3n_1: c\u00f3digo condici\u00f3n_1 [break;] \u2026 case condici\u00f3n_n: c\u00f3digo condici\u00f3n_n [break;] default: c\u00f3digo default} Estructura de control condicional basada en la evaluaci\u00f3n del valor de una expresi\u00f3n for(ini; condici\u00f3n; actualizaci\u00f3n){ c\u00f3digo bucle} Bucle condicional while(condici\u00f3n) { c\u00f3digo bucle} Bucle incondicional do { c\u00f3digo bucle} while(condicion) Bucle incondicional break Salida de un bloque de c\u00f3digo continue Parada de la ejecuci\u00f3n de un bucle para volver a evaluar la condici\u00f3n de parada try { c\u00f3digo js}catch(err) { c\u00f3digo que gestiona el error}finally { c\u00f3digo a ejecutar haya o no error} Captura y gesti\u00f3n de errores en el c\u00f3digo Operadores Operador Denominaci\u00f3n = Asignaci\u00f3n +, -, \\*, /, % Operadores aritm\u00e9ticos (act\u00faan sobre valores num\u00e9ricos) ++, -- Incremento, decremento **+=, -=, \\*=, /=, %=** Operaci\u00f3n aritm\u00e9tica + Asignaci\u00f3n +, += Concatenaci\u00f3n de Strings ==, !=, >, <, >=, <= Comparadores de valor **===** (igual valor e igual tipo)**!==** (distinto valor y distinto tipo) Comparadores de valor y tipo &&, ||, ! Operadores l\u00f3gicos < html > < head > < script > var a = 3 ; function mostrarVariable ( valor ) { alert ( valor ); // Aqu\u00ed mostramos el valor que recibe como par\u00e1metro alert ( a ); // Aqu\u00ed, el valor de la variable global } </ script > </ head > < body > Ejemplo sencillo de uso de < i > JavaScript </ i > < input type = \"button\" value = \"Pulsar...\" onclick = \"mostrarVariable(a)\" /> < script > alert ( a ); a = 5 ; </ script > </ body > </ html > La secuencia de acciones realizadas por el int\u00e9rprete JavaScript al interpretar este c\u00f3digo es: Crear una variable a y asignarle el valor num\u00e9rico 3.* * Crear una funci\u00f3n mostrarVariable que queda a la espera de ser invocada. Invocar a la funci\u00f3n alert para mostrar el valor actual de a . Cambiar el valor de a asign\u00e1ndole el valor num\u00e9rico 5. \u00bfCu\u00e1ndo se invoca la funci\u00f3n que hemos creado? En este caso, al pulsar el bot\u00f3n que hemos a\u00f1adido en el cuerpo del documento. Para ello utilizamos su atributo onclick , en el que se indica el c\u00f3digo JavaScript a ejecutar al \"hacer clic\" sobre el elemento. Lo que en realidad estamos haciendo con esa definici\u00f3n es asociar una funcionalidad a un evento, pero de momento no debes preocuparte por ello, en las siguientes secciones trataremos los eventos HTML en detalle. eventos Estos son algunos de los eventos HTML que m\u00e1s habitualmente se procesan en las aplicaciones web. Aunque procesando estos eventos podr\u00edas desarrollar cualquier aplicaci\u00f3n web t\u00edpica, como ya sabes, puedes encontrar la lista completa de eventos HTML en la documentaci\u00f3n de referencia de la W3C . Recuerda que para procesar un evento tienes que dar valor a la propiedad correspondiente en el elemento HTML, por ejemplo, para procesar el evento click debes fijar la propiedad onclick : click : se produce cuando el usuario hace click sobre el elemento HTML. mouseover : se produce cuando el usuario entra con el rat\u00f3n dentro del elemento HTML. mouseout : se produce cuando el usuario sale con el rat\u00f3n del elemento HTML. focus : se produce cuando el elemento HTML recibe el foco. blur : se produce cuando el elemento HTML pierde el foco. change : se produce cuando el valor del elemento HTML cambia (para < input >, < select > y < textarea >). keydown/keypress : se producen cuando el usuario presiona una tecla estando dentro del elemento HTML. Aunque realmente son eventos distintos, en la mayor\u00eda de las ocasiones se pueden considerar equivalentes. keyup : se produce cuando el usuario suelta una tecla estando dentro del elemento HTML. submit : se produce cuando se hace el submit de un formulario (para < form >). load : se produce cuando finaliza la carga del elemento HTML. T\u00edpicamente se utiliza para validar la carga del documento. unload : se produce cuando se descarga la p\u00e1gina (para < body >). error : se produce cuando se produce un error al cargar un fichero externo. A continuaci\u00f3n, pod\u00e9is ver un ejemplo ilustrativo de c\u00f3mo vincular c\u00f3digo JavaScript con alguno de estos eventos. El fichero eventos.html contiene el c\u00f3digo con el que se trabaja. Introducci\u00f3n a AJAX La clave de todo este proceso de llamadas as\u00edncronas en segundo plano al servidor es el objeto XMLHttpRequest* . Al tratarse de un objeto JavaScript*, la sintaxis para crearlo dentro de nuestro c\u00f3digo JS es: xmlhttp=new XMLHttpRequest(); Una vez instanciado, ofrece dos m\u00e9todos para hacer una petici\u00f3n al servidor: open(tipo, url, as\u00edncrona) : Permite configurar los datos de la petici\u00f3n. En cierta medida, podemos considerar que la configuraci\u00f3n de la llamada es an\u00e1loga a la especificaci\u00f3n de los datos de env\u00edo de un formulario en el documento HTML. El tipo de petici\u00f3n (atributo type del elemento < form >) podr\u00e1 ser \"GET\" o \"POST\". En el par\u00e1metro url indicaremos la url del servicio encargado de procesar la petici\u00f3n en el servidor (atributo action del elemento < form >). Y el tercer par\u00e1metro, sin equivalencia en el caso de un formulario en el que las peticiones al servidor conllevan la carga s\u00edncrona de un nuevo documento, es el indicador de si la petici\u00f3n debe procesarse de forma as\u00edncrona ( true ) o s\u00edncrona ( false ). Cuidado que es un indicador de asincronismo, no de sincronismo, lo que en ocasiones suele inducir a error a los desarrolladores. send([query_string]) Realiza el env\u00edo de la petici\u00f3n al servidor . Si no se le pasan par\u00e1metros, se realiza una petici\u00f3n GET en la que los par\u00e1metros de la llamada se han debido informar como query string en la url indicada en la llamada al m\u00e9todo open . Para peticiones POST, el m\u00e9todo send recibe un query string con los par\u00e1metros que enviar al servidor (p.ej., \"param1=valor1&param2=valor2\"). En este \u00faltimo caso, para que los par\u00e1metros se env\u00eden en la cabecera HTTP en lugar de en la URL, adicionalmente se debe incluir la siguiente l\u00ednea antes del env\u00edo: xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); As\u00ed, para realizar una petici\u00f3n GET as\u00edncrona que descargue la p\u00e1gina de acceso al sitio web de la Universidad Aut\u00f3noma de Madrid, har\u00edamos lo siguiente: xmlhttp = new XMLHttpRequest();xmlhttp.open(\"GET\",\"http://www.uam.com\",true);xmlhttp.send(); jQuery $(selector).accion() $(\"div#contenedor_lista input:checked\").parent().hide() $(document).ready(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Esto se utiliza tan habitualmente que incluso existe una sintaxis abreviada para asignar funcionalidad al evento ready() del document . Lo siguiente es completamente equivalente a la asignaci\u00f3n est\u00e1ndar: $(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Para reforzar los conocimientos adquiridos durante la lecci\u00f3n 2, le recomendamos visitar los siguientes sitios: P\u00e1gina del gestor de paquetes que incluye Python https://pypi.org https://realpython.com/what-is-pip/ https://realpython.com/pipenv-guide/ https://docs.scipy.org/doc/numpy-1.14.5/reference/ https://matplotlib.org https://www.edureka.co/blog/python-libraries/ https://packaging.python.org/tutorials/installing-packages/ https://packaging.python.org/tutorials/packaging-projects/ https://numpy.org/doc/stable/user/quickstart.html https://numpy.org/doc/stable/user/absolute_beginners.html https://www.geeksforgeeks.org/ init -in-python/ https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://es.wikipedia.org/wiki/Clase_(inform\u00e1tica) https://es.wikipedia.org/wiki/Instancia_(inform\u00e1tica) https://es.wikipedia.org/wiki/Constructor_(inform\u00e1tica) https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://www.programiz.com/python-programming/matrix https://matrix.reshish.com/es/multiplication.php https://realpython.com/python-modules-packages/#python-modules-overview https://www.geeksforgeeks.org/python-classes-and-objects/ Python Modules and Packages \u2013 An Introduction \u2013 Real Python Python packages: How to create and import them? Python Tutorial Python pip Python PIP Tutorial pandas: powerful Python data analysis toolkit numpy \u00b7 PyPI El Ingeniero Gonz\u00e1lez en cada video iba mostrando y explicando c\u00f3digo de Python, lo mas recomendable es que usted vaya replicando el mismo. A continuaci\u00f3n se comparte el c\u00f3digo que se utiliz\u00f3 y explic\u00f3 en los videos de lecci\u00f3n 5 (es importante que usted ya haya instalado Python para correr este c\u00f3digo): Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Importante: el c\u00f3digo fue creado siguiendo el siguiente formato: PrintX_DIAPOSITIVAY_PZ Donde X es el orden del programa en cuanto a que momento se utiliza, Y es la diapositiva donde se usa y Z la presentaci\u00f3n.","title":"Js"},{"location":"web/js/#js","text":"","title":"js"},{"location":"web/js/#estructuras-de-control","text":"C\u00f3digo Denominaci\u00f3n if(condici\u00f3n) { c\u00f3digo true }else { c\u00f3digo false} Estructura de control condicional (condici\u00f3n) ? valor_true : valor_false Operador de control condicional switch(expresi\u00f3n) { case condici\u00f3n_1: c\u00f3digo condici\u00f3n_1 [break;] \u2026 case condici\u00f3n_n: c\u00f3digo condici\u00f3n_n [break;] default: c\u00f3digo default} Estructura de control condicional basada en la evaluaci\u00f3n del valor de una expresi\u00f3n for(ini; condici\u00f3n; actualizaci\u00f3n){ c\u00f3digo bucle} Bucle condicional while(condici\u00f3n) { c\u00f3digo bucle} Bucle incondicional do { c\u00f3digo bucle} while(condicion) Bucle incondicional break Salida de un bloque de c\u00f3digo continue Parada de la ejecuci\u00f3n de un bucle para volver a evaluar la condici\u00f3n de parada try { c\u00f3digo js}catch(err) { c\u00f3digo que gestiona el error}finally { c\u00f3digo a ejecutar haya o no error} Captura y gesti\u00f3n de errores en el c\u00f3digo","title":"Estructuras de control"},{"location":"web/js/#operadores","text":"Operador Denominaci\u00f3n = Asignaci\u00f3n +, -, \\*, /, % Operadores aritm\u00e9ticos (act\u00faan sobre valores num\u00e9ricos) ++, -- Incremento, decremento **+=, -=, \\*=, /=, %=** Operaci\u00f3n aritm\u00e9tica + Asignaci\u00f3n +, += Concatenaci\u00f3n de Strings ==, !=, >, <, >=, <= Comparadores de valor **===** (igual valor e igual tipo)**!==** (distinto valor y distinto tipo) Comparadores de valor y tipo &&, ||, ! Operadores l\u00f3gicos < html > < head > < script > var a = 3 ; function mostrarVariable ( valor ) { alert ( valor ); // Aqu\u00ed mostramos el valor que recibe como par\u00e1metro alert ( a ); // Aqu\u00ed, el valor de la variable global } </ script > </ head > < body > Ejemplo sencillo de uso de < i > JavaScript </ i > < input type = \"button\" value = \"Pulsar...\" onclick = \"mostrarVariable(a)\" /> < script > alert ( a ); a = 5 ; </ script > </ body > </ html > La secuencia de acciones realizadas por el int\u00e9rprete JavaScript al interpretar este c\u00f3digo es: Crear una variable a y asignarle el valor num\u00e9rico 3.* * Crear una funci\u00f3n mostrarVariable que queda a la espera de ser invocada. Invocar a la funci\u00f3n alert para mostrar el valor actual de a . Cambiar el valor de a asign\u00e1ndole el valor num\u00e9rico 5. \u00bfCu\u00e1ndo se invoca la funci\u00f3n que hemos creado? En este caso, al pulsar el bot\u00f3n que hemos a\u00f1adido en el cuerpo del documento. Para ello utilizamos su atributo onclick , en el que se indica el c\u00f3digo JavaScript a ejecutar al \"hacer clic\" sobre el elemento. Lo que en realidad estamos haciendo con esa definici\u00f3n es asociar una funcionalidad a un evento, pero de momento no debes preocuparte por ello, en las siguientes secciones trataremos los eventos HTML en detalle.","title":"Operadores"},{"location":"web/js/#eventos","text":"Estos son algunos de los eventos HTML que m\u00e1s habitualmente se procesan en las aplicaciones web. Aunque procesando estos eventos podr\u00edas desarrollar cualquier aplicaci\u00f3n web t\u00edpica, como ya sabes, puedes encontrar la lista completa de eventos HTML en la documentaci\u00f3n de referencia de la W3C . Recuerda que para procesar un evento tienes que dar valor a la propiedad correspondiente en el elemento HTML, por ejemplo, para procesar el evento click debes fijar la propiedad onclick : click : se produce cuando el usuario hace click sobre el elemento HTML. mouseover : se produce cuando el usuario entra con el rat\u00f3n dentro del elemento HTML. mouseout : se produce cuando el usuario sale con el rat\u00f3n del elemento HTML. focus : se produce cuando el elemento HTML recibe el foco. blur : se produce cuando el elemento HTML pierde el foco. change : se produce cuando el valor del elemento HTML cambia (para < input >, < select > y < textarea >). keydown/keypress : se producen cuando el usuario presiona una tecla estando dentro del elemento HTML. Aunque realmente son eventos distintos, en la mayor\u00eda de las ocasiones se pueden considerar equivalentes. keyup : se produce cuando el usuario suelta una tecla estando dentro del elemento HTML. submit : se produce cuando se hace el submit de un formulario (para < form >). load : se produce cuando finaliza la carga del elemento HTML. T\u00edpicamente se utiliza para validar la carga del documento. unload : se produce cuando se descarga la p\u00e1gina (para < body >). error : se produce cuando se produce un error al cargar un fichero externo. A continuaci\u00f3n, pod\u00e9is ver un ejemplo ilustrativo de c\u00f3mo vincular c\u00f3digo JavaScript con alguno de estos eventos. El fichero eventos.html contiene el c\u00f3digo con el que se trabaja.","title":"eventos"},{"location":"web/js/#introduccion-a-ajax","text":"La clave de todo este proceso de llamadas as\u00edncronas en segundo plano al servidor es el objeto XMLHttpRequest* . Al tratarse de un objeto JavaScript*, la sintaxis para crearlo dentro de nuestro c\u00f3digo JS es: xmlhttp=new XMLHttpRequest(); Una vez instanciado, ofrece dos m\u00e9todos para hacer una petici\u00f3n al servidor: open(tipo, url, as\u00edncrona) : Permite configurar los datos de la petici\u00f3n. En cierta medida, podemos considerar que la configuraci\u00f3n de la llamada es an\u00e1loga a la especificaci\u00f3n de los datos de env\u00edo de un formulario en el documento HTML. El tipo de petici\u00f3n (atributo type del elemento < form >) podr\u00e1 ser \"GET\" o \"POST\". En el par\u00e1metro url indicaremos la url del servicio encargado de procesar la petici\u00f3n en el servidor (atributo action del elemento < form >). Y el tercer par\u00e1metro, sin equivalencia en el caso de un formulario en el que las peticiones al servidor conllevan la carga s\u00edncrona de un nuevo documento, es el indicador de si la petici\u00f3n debe procesarse de forma as\u00edncrona ( true ) o s\u00edncrona ( false ). Cuidado que es un indicador de asincronismo, no de sincronismo, lo que en ocasiones suele inducir a error a los desarrolladores. send([query_string]) Realiza el env\u00edo de la petici\u00f3n al servidor . Si no se le pasan par\u00e1metros, se realiza una petici\u00f3n GET en la que los par\u00e1metros de la llamada se han debido informar como query string en la url indicada en la llamada al m\u00e9todo open . Para peticiones POST, el m\u00e9todo send recibe un query string con los par\u00e1metros que enviar al servidor (p.ej., \"param1=valor1&param2=valor2\"). En este \u00faltimo caso, para que los par\u00e1metros se env\u00eden en la cabecera HTTP en lugar de en la URL, adicionalmente se debe incluir la siguiente l\u00ednea antes del env\u00edo: xmlhttp.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); As\u00ed, para realizar una petici\u00f3n GET as\u00edncrona que descargue la p\u00e1gina de acceso al sitio web de la Universidad Aut\u00f3noma de Madrid, har\u00edamos lo siguiente: xmlhttp = new XMLHttpRequest();xmlhttp.open(\"GET\",\"http://www.uam.com\",true);xmlhttp.send();","title":"Introducci\u00f3n a AJAX"},{"location":"web/js/#jquery","text":"$(selector).accion() $(\"div#contenedor_lista input:checked\").parent().hide() $(document).ready(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Esto se utiliza tan habitualmente que incluso existe una sintaxis abreviada para asignar funcionalidad al evento ready() del document . Lo siguiente es completamente equivalente a la asignaci\u00f3n est\u00e1ndar: $(function() { // T\u00fa c\u00f3digo ir\u00e1 aqu\u00ed}); Para reforzar los conocimientos adquiridos durante la lecci\u00f3n 2, le recomendamos visitar los siguientes sitios: P\u00e1gina del gestor de paquetes que incluye Python https://pypi.org https://realpython.com/what-is-pip/ https://realpython.com/pipenv-guide/ https://docs.scipy.org/doc/numpy-1.14.5/reference/ https://matplotlib.org https://www.edureka.co/blog/python-libraries/ https://packaging.python.org/tutorials/installing-packages/ https://packaging.python.org/tutorials/packaging-projects/ https://numpy.org/doc/stable/user/quickstart.html https://numpy.org/doc/stable/user/absolute_beginners.html https://www.geeksforgeeks.org/ init -in-python/ https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://es.wikipedia.org/wiki/Clase_(inform\u00e1tica) https://es.wikipedia.org/wiki/Instancia_(inform\u00e1tica) https://es.wikipedia.org/wiki/Constructor_(inform\u00e1tica) https://www.w3schools.com/python/python_classes.asp https://www.w3schools.com/python/python_inheritance.asp https://www.programiz.com/python-programming/matrix https://matrix.reshish.com/es/multiplication.php https://realpython.com/python-modules-packages/#python-modules-overview https://www.geeksforgeeks.org/python-classes-and-objects/ Python Modules and Packages \u2013 An Introduction \u2013 Real Python Python packages: How to create and import them? Python Tutorial Python pip Python PIP Tutorial pandas: powerful Python data analysis toolkit numpy \u00b7 PyPI El Ingeniero Gonz\u00e1lez en cada video iba mostrando y explicando c\u00f3digo de Python, lo mas recomendable es que usted vaya replicando el mismo. A continuaci\u00f3n se comparte el c\u00f3digo que se utiliz\u00f3 y explic\u00f3 en los videos de lecci\u00f3n 5 (es importante que usted ya haya instalado Python para correr este c\u00f3digo): Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Dar clic aqu\u00ed para descargar c\u00f3digo Importante: el c\u00f3digo fue creado siguiendo el siguiente formato: PrintX_DIAPOSITIVAY_PZ Donde X es el orden del programa en cuanto a que momento se utiliza, Y es la diapositiva donde se usa y Z la presentaci\u00f3n.","title":"jQuery"},{"location":"web/py/","text":"py links Introduction to Python: Absolute Beginner (edX). Introducci\u00f3n al desarrollo de aplicaciones web (edx) ** de aqui es la documentacion Curso de Python B\u00e1sico Gratis (Web C\u00f3digo Facilito). venv requirements.txt flask pk@pk:~$ type vvvv vvvv () { deactivate ; python3.8 -m venv ./.venv ; source ./.venv/bin/activate ; pip install -r requirements.txt ; python app.py } pk@pk:~$ pk@pk:~$ flask ejemplo basico app.py import sys from flask import Flask , request app = Flask ( __name__ ) @app . route ( '/' ) def index (): user_agent = request . headers . get ( 'User-Agent' ) return '<p>Your browser is %s </p>' % user_agent @app . route ( '/processLogin' , methods = [ 'POST' ]) def process_login (): missing = [] fields = [ 'email' , 'passwd' , 'login_submit' ] for field in fields : value = request . form . get ( field , None ) if value is None : missing . append ( field ) if missing : return \"Warning: Some fields are missing\" return '<!DOCTYPE html> ' \\ '<html lang=\"es\">' \\ '<head>' \\ '<link href=\"static/css/my-socnet-style.css\" rel=\"stylesheet\" type=\"text/css\"/>' \\ '<title> Home - SocNet </title>' \\ '</head>' \\ '<body> <div id =\"container\">' \\ '<a href=\"/\"> SocNet </a> | <a href=\"home\"> Home </a> | <a href=\"login\"> Log In </a> | <a href=\"signup\"> Sign Up </a>' \\ '<h1>Data from Form: Login</h1>' \\ '<form><label>email: ' + request . form [ 'email' ] + \\ '</label><br><label>passwd: ' + request . form [ 'passwd' ] + \\ '</label></form></div></body>' \\ '</html>' if __name__ == '__main__' : if sys . platform == 'ubuntu' : app . run ( debug = True , port = 8080 ) else : app . run ( debug = True , port = 80 ) index.html flask. ejem buenisimo api json ''' http://127.0.0.1:8080/songs/all import requests cancion={ 'Artista':'dfasfd', 'Nombre':'jojo' } respuesta=requests.get('http://127.0.0.1:8080/songs/all') print('\\n',respuesta.content.decode()) respuesta=requests.post('http://127.0.0.1:8080/songs/new',json=cancion) print('\\n',respuesta.content.decode()) respuesta=requests.get('http://127.0.0.1:8080/songs/all') print('\\n',respuesta.content.decode()) respuesta=requests.patch('http://127.0.0.1:8080/songs/2', json={'Artista':'jijiji'}) print('\\n',respuesta.content.decode()) respuesta=requests.get('http://127.0.0.1:8080/songs/all') print('\\n',respuesta.content.decode()) ''' # Ejemplo API from flask import Flask , request , jsonify import json app = Flask ( __name__ ) song_db = [ { \"id\" : 0 , \"Artista\" : \"Air Supply\" , \"Nombre\" : \"Making Love Out of Nothing at All\" }, { \"id\" : 1 , \"Artista\" : \"Bonnie Tyle\" , \"Nombre\" : \"Total Eclipse Of The Heart\" }, { \"id\" : 2 , \"Artista\" : \"George Michael\" , \"Nombre\" : \"Careless Whisper\" }, { \"id\" : 3 , \"Artista\" : \"Berlin\" , \"Nombre\" : \"Take My Breath Away\" }, { \"id\" : 4 , \"Artista\" : \"Queen\" , \"Nombre\" : \"Bohemian Rhapsody\" } ] # GET | returns the whole catalog @app . route ( \"/songs/all\" , methods = [ \"GET\" ]) def get_all (): return jsonify ( song_db ), 200 # GET | returns an entry by an id @app . route ( \"/songs/<int:song_id>\" , methods = [ \"GET\" ]) def get_song ( song_id ): song_result = next ( ( song for song in song_db if song [ \"id\" ] == song_id ), None ) if song_result : return ( jsonify ( song_result ), 200 ) else : return \"404 Not Found\" , 404 # GET | returns all songs with the same name @app . route ( \"/songs/search/<string:song_name>\" , methods = [ \"GET\" ]) def search_song ( song_name ): songs = [ song for song in song_db if song_name in song [ \"Nombre\" ]] if songs : return ( jsonify ( songs ), 200 ) else : return \"404 Not Found\" , 404 # POST | creates a new entry in the catalog @app . route ( \"/songs/new\" , methods = [ \"POST\" ]) def post_song (): if request . data : song_data = json . loads ( request . data ) song_id = max ([ song [ 'id' ] for song in song_db ]) + 1 song_artist = song_data [ \"Artista\" ] song_name = song_data [ \"Nombre\" ] new_song = { \"id\" : song_id , \"Artista\" : song_artist , \"Nombre\" : song_name } song_db . append ( new_song ) return jsonify ( new_song ), 200 else : return \"400 Bad Request\" , 400 # DELETE | deletes an entry in the catalog by an id @app . route ( \"/songs/<int:song_id>\" , methods = [ \"DELETE\" ]) def delete_song ( song_id ): for idx , song in enumerate ( song_db ): if song [ \"id\" ] == song_id : song_db . pop ( idx ) return \"Register Deleted\" , 200 return \"Not Found\" , 404 # PUT | replaces an entry in the catalog, creates a new entry if it doesn't exist @app . route ( \"/songs/<int:song_id>\" , methods = [ \"PUT\" ]) def put_song ( song_id ): if request . data : song_data = json . loads ( request . data ) song_artist = song_data [ \"Artista\" ] song_name = song_data [ \"Nombre\" ] edit_song = { \"id\" : song_id , \"Artista\" : song_artist , \"Nombre\" : song_name } for idx , song in enumerate ( song_db ): if song [ \"id\" ] == song_id : song_db [ idx ] = edit_song return ( jsonify ( edit_song ), 200 ) edit_song [ \"id\" ] = max ([ song [ 'id' ] for song in song_db ]) + 1 song_db . append ( edit_song ) return ( jsonify ( edit_song ), 200 ) else : return \"Bad Request\" , 400 # PATCH | edits an entry in the catalog, fails if it doesn't exist @app . route ( \"/songs/<int:song_id>\" , methods = [ \"PATCH\" ]) def patch_song ( song_id ): if request . data : for idx , song in enumerate ( song_db ): if song [ \"id\" ] == song_id : song_data = json . loads ( request . data ) for edit_key in song_data : song [ edit_key ] = song_data [ edit_key ] return ( jsonify ( song ), 200 ) return \"Not Found\" , 404 else : return \"Bad Request\" , 400 if __name__ == '__main__' : app . run ( debug = True , port = 8080 ) json Las estructuras de JSON tienen una traducci\u00f3n directa a estructuras Python: Los objetos JSON son representados como diccionarios en Python Los arrays JSON son representados como listas en Python true y false en JSON son valores del tipo boolean en Python Las cadenas en JSON son cadenas en Python Los n\u00fameros en JSON son float o integer , seg\u00fan corresponda, en Python Por este motivo, las funciones para leer y escribir ficheros JSON son muy sencillas de utilizar. En ambos casos recurrimos a la biblioteca JSON, as\u00ed que lo primero que debemos hacer es: import json Lectura La funci\u00f3n para leer un fichero JSON es json.load. Como par\u00e1metro un fichero, as\u00ed que una forma normal de usarla es: with open(\u201cnombre_fichero.json\u201d, 'r') as f: data = json.load(f) Despu\u00e9s de ejecutar esto, la variable data contendr\u00e1 un diccionario con los datos cargados del fichero. Si por ejemplo hubi\u00e9ramos cargado el fichero con los datos del usuario James visto en la secci\u00f3n anterior, ahora data[\u2018user_name\u2019] ser\u00eda \u201cJames\u201d y data[\u2018messages\u2019] ser\u00eda una lista Python con los mensajes publicados por James. Escritura Volcar una estructura Python a un fichero JSON es igual de sencillo. Supongamos que tenemos la siguiente inicializaci\u00f3n de la variable datos: da t os = { \"user_name\" : \"James\" , \"password\" : \u201c 007 \u201d , \"messages\" : [ ( 1532648502.113984 , \u201cme nsa je 1 \u201d) , ( 1532648642.729385 , \u201cme nsa je 1 \u201d) ], \"email\" : sessio n [ 'email' ], \"friends\" : sessio n [ ' fr ie n ds' ] } Entonces guardar los datos en el fichero correspondiente ser\u00eda: with open ( \u201c james . bond @mi6 . uk \u201d , 'w' ) as f : json . dump ( datos , f ) sesiones Ya hemos dicho en varias oportunidades que el protocolo HTTP no tiene estado, que no recuerda. \u00bfQu\u00e9 significa eso en la pr\u00e1ctica? Que necesitamos informaci\u00f3n adicional para implementar una \u201cconversaci\u00f3n\u201d entre cliente y servidor. Esta idea de conversaci\u00f3n, donde ambas partes recuerdan lo que han hablado hasta el momento, se llama sesi\u00f3n . Aunque el concepto o la duraci\u00f3n de una sesi\u00f3n puede variar en distintos entornos, b\u00e1sicamente es el conjunto de interacciones entre cliente y servidor en un lapso de tiempo razonable. La primera vez que un cliente realiza una petici\u00f3n, despu\u00e9s de un tiempo sin interactuar, el servidor abre una sesi\u00f3n . Las subsecuentes peticiones desde ese cliente se consideran dentro de la misma sesi\u00f3n. Si pasa mucho tiempo sin que el cliente realice una petici\u00f3n, el servidor asume que ya no est\u00e1 conectado y termina la sesi\u00f3n. La biblioteca Flask nos ofrece este concepto de sesi\u00f3n. Pero si HTTP no tiene informaci\u00f3n espec\u00edfica que permita identificar al usuario o la sesi\u00f3n, \u00bfc\u00f3mo sabe Flask a qu\u00e9 usuario corresponde una determinada petici\u00f3n? Existen al menos 3 formas de que una petici\u00f3n HTTP transporte informaci\u00f3n que permita identificar al usuario o la sesi\u00f3n: Cookies : las cookies son peque\u00f1os ficheros que se adjuntan a una respuesta HTTP, con informaci\u00f3n de identificaci\u00f3n de usuario. En sucesivas peticiones HTTP, el navegador incluye ese fichero autom\u00e1ticamente, por lo que el servidor podr\u00e1 tener la identificaci\u00f3n de ese usuario. Campos ocultos : en los formularios que el servidor env\u00eda a cliente para que sean completados, incluyo un campo del tipo input que no se muestra al usuario; ese campo lleva informaci\u00f3n que cuando los datos del formulario se env\u00eden de vuelta al servidor le servir\u00e1 para identificar al cliente. Reescritura de URLs : aunque nos parezcan iguales, el servidor introduce autom\u00e1ticamente peque\u00f1as modificaciones a las URLs; de esta forma, la URL espec\u00edfica que solicite permitir\u00e1 al servidor identificar al cliente. La buena noticia es que, generalmente, el mecanismo que se use para transportar la informaci\u00f3n de sesi\u00f3n no es visible al desarrollador de la aplicaci\u00f3n web. Esto es exactamente lo que ocurre con el soporte de sesiones que nos ofrece Flask, y que veremos a continuaci\u00f3n. Vamos a ver c\u00f3mo podemos manejar una sesi\u00f3n en Python y Flask para poder almacenar informaci\u00f3n entre cada una de las peticiones que el cliente haga al servidor. Objeto Flask Session El objeto que nos guarda la informaci\u00f3n entre sesiones se llama session. Lo primero ser\u00e1 importarlo dentro de nuestro c\u00f3digo Python para luego poder usarlo: from flask import Flask, session Como la informaci\u00f3n de la sesi\u00f3n viaja del servidor al cliente ida y vuelta, es importante que nadie en el camino, ni siquiera el propio cliente, puedan alterar esa informaci\u00f3n. En particular, se debe evitar que alguien de fuera \u201ctome control\u201d de la sesi\u00f3n. En seguridad inform\u00e1tica, este tipo de ataque se conoce como CSRF (Cross-site request forgery) o robo de sesi\u00f3n. Para asegurarse que eso no ocurre, Flask utiliza t\u00e9cnicas de encriptaci\u00f3n para proteger la informaci\u00f3n. Para eso, necesita una clav de encriptaci\u00f3n/desencriptaci\u00f3n. Esta clave, que s\u00f3lo debe conocer el servidor y que debe ser distinta para todos los programas servidor, se crea en el propio c\u00f3digo del servidor. Por ejemplo: app.secret_key = 'esto-es-una-clave-muy-secreta' De hecho, en el c\u00f3digo de nuestra aplicaci\u00f3n SocNet habr\u00e1s visto una l\u00ednea similar a esta: app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' Ahora ya sabes para qu\u00e9 sirve. Si quieres tener m\u00e1s informaci\u00f3n de este problema de seguridad inform\u00e1tica y su soluci\u00f3n, puedes leer aqu\u00ed . Ahora vamos a ver ejemplo de c\u00f3mo utilizamos las sesiones en nuestra aplicaci\u00f3n favorita. La primera funci\u00f3n, *load_user(email, passwd)* , intenta cargar los datos desde un fichero. Importante : aqu\u00ed almacenamos los datos en un fichero por una cuesti\u00f3n de simplicidad. En aplicaciones con cientos o miles de usuarios lo normal es almacenar los datos en una base de datos propiamente dicha. Si el fichero existe, carga los datos y a continuaci\u00f3n comprueba que la clave suministrada coincida con la que est\u00e1 almacenada. Nota de seguridad : otra vez, para facilitar las explicaciones y la comprensi\u00f3n de los conceptos b\u00e1sicos, realizamos algunas simplificaciones que antes de hacer p\u00fablico un sistema deben ser corregidas. Por ejemplo, nunca se debe guardar una clave de usuario \u201cen claro\u201d, siempre se debe hacer codificada con alg\u00fan algoritmo como por ejemplo SHA-256. Lamentable estas cuestiones quedan fuera del \u00e1mbito de este curso. Si todas las condiciones son correctas, la funci\u00f3n guarda los datos relevantes del usuario (nombre, mensajes que ha escrito hasta el momento, la clave, su correo electr\u00f3nico y la lista de amigos) en la sesi\u00f3n , para que est\u00e9n disponibles para las pr\u00f3xima llamadas desde el cliente. def load_user ( email , passwd ): \"\"\" It loads data for the given user (identified by email) from the data directory. It looks for a file whose name matches the user email :param email: user id :param passwd: password to check in order to validate the user :return: content of the home page (app basic page) if user exists and password is correct \"\"\" file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if not os . path . isfile ( file_path ): return process_error ( \"User not found / No existe un usuario con ese nombre\" , url_for ( \"login\" )) with open ( file_path , 'r' ) as f : data = json . load ( f ) if data [ 'password' ] != passwd : return process_error ( \"Incorrect password / la clave no es correcta\" , url_for ( \"login\" )) session [ 'user_name' ] = data [ 'user_name' ] session [ 'messages' ] = data [ 'messages' ] session [ 'password' ] = passwd session [ 'email' ] = email session [ 'friends' ] = data [ 'friends' ] return redirect ( url_for ( \"home\" )) De la misma forma, cuando un usuario quiere salir del sistema, debemos guardar los datos en el fichero (base de datos) para que est\u00e9n disponibles la pr\u00f3xima vez que el usuario vuelva a nuestra aplicaci\u00f3n. Este es el objetivo de la funci\u00f3n save_current_user() , que vuelca los datos de session en el fichero correspondiente. Por otra parte, cuando un usuario se da de alta, se debe crear el fichero, previa comprobaci\u00f3n que no exista un usuario con el mismo identificador (correo electr\u00f3nico). Esto es lo que hace la funci\u00f3n create_user_file(name, email, passwd, passwd_confirmation) . def save_current_user (): datos = { \"user_name\" : session [ \"user_name\" ], \"password\" : session [ 'password' ], \"messages\" : session [ 'messages' ], # lista de tuplas (time_stamp, mensaje) \"email\" : session [ 'email' ], \"friends\" : session [ 'friends' ] } file_path = os . path . join ( SITE_ROOT , \"data/\" , session [ 'email' ]) with open ( file_path , 'w' ) as f : json . dump ( datos , f ) def create_user_file ( name , email , passwd , passwd_confirmation ): \"\"\" It creates the file (in the /data directory) for storing user data. The file name will match the user email. If the file already exists, it returns an error. If the password does not match the confirmation, it returns an error. :param name: Name or nickname of the user :param email: user email, which will be later used for retrieving data :param passwd: password for future logins :param passwd_confirmation: confirmation, must match the password :return: if no error is found, it sends the user to the home page \"\"\" directory = os . path . join ( SITE_ROOT , \"data\" ) if not os . path . exists ( directory ): os . makedirs ( directory ) file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if os . path . isfile ( file_path ): return process_error ( \"The email is already used, you must select a different email / Ya existe un usuario con ese nombre\" , url_for ( \"signup\" )) if passwd != passwd_confirmation : return process_error ( \"Your password and confirmation password do not match / Las claves no coinciden\" , url_for ( \"signup\" )) datos = { \"user_name\" : name , \"password\" : passwd , \"messages\" : [], \"friends\" : [] } with open ( file_path , 'w' ) as f : json . dump ( datos , f ) session [ 'user_name' ] = name session [ 'password' ] = passwd session [ 'messages' ] = [] session [ 'friends' ] = [] session [ 'email' ] = email return redirect ( url_for ( \"home\" )) Iterando sobre los elementos en Beautiful Soup Hasta el momento se han visto dos principales maneras de c\u00f3mo se puede utilizar el \u00e1rbol jer\u00e1rquico producido por BeautifulSoup con base a una p\u00e1gina web: utilizando m\u00e9todos de b\u00fasqueda, y navegando manualmente por los elementos, cada uno con sus ventajas y desventajas. Sin embargo, podemos utilizar un enfoque intermedio entre estos dos extremos y es el de utilizar m\u00e9todos de iteraci\u00f3n sobre los elementos. De esta forma podemos tener la ventaja de la flexibilidad de la b\u00fasqueda, pero con el poder de ajustar la selecci\u00f3n de los elementos de forma manual. Para lograr este objetivo, BeautifulSoup cuenta con diferentes herramientas y m\u00e9todos,siendo uno de ellos el atributo \u201c descendants \u201d. Su comportamiento es similar al de \u201c children \u201d pero no solo se limita a los elementos inmediatos, si no que enlista todos los elementos, es decir, los hijos, los hijos de los hijos, etc. # Ejemplo 1 import requests from bs4 import BeautifulSoup page = requests . get ( \u201c https : // datolok . github . io / python - edx / webscrapping / simple . html \u201d ) soup = BeautifulSoup ( page . content , \u2018 html . parser \u2019 ) for element in soup . descendants : print ( \"Element {} : \\n {} \" . format ( item , element )) En este c\u00f3digo se carga la p\u00e1gina que se ha utilizado de ejemplo y se imprimen todos los elementos contenidos por medio de un ciclo for. Esto se puede combinar con otros conceptos, como la de expresiones regulares, para identificar palabras claves o patrones de informaci\u00f3n. Este proceso de b\u00fasqueda dentro de un elemento en particular puede aplicarse al resultado de otros procesos como el de b\u00fasqueda o navegaci\u00f3n. # Ejemplo 2 import requests from bs4 import BeautifulSoup page = requests . get ( \u201c https : // datolok . github . io / python - edx / webscrapping / simple . html \u201d ) soup = BeautifulSoup ( page . content , \u2018 html . parser \u2019 ) for p in soup . find_all ( \u201c p \u201d ): if \u201c contenido \u201d in p . get_text (): print ( p . get_text ()) En este c\u00f3digo se encuentran todos los elementos de tipo p\u00e1rrafo en el documento, se iteran sobre todos los resultados y se imprimen aquellos que contengan la palabra \u201ccontenido\u201d. Como se puede observar esto abre un abanico de nuevas posibilidades para automatizar nuestro proceso de b\u00fasqueda y no depender demasiado en que la estructura de la p\u00e1gina web no var\u00ede. Igualmente, no estamos limitados a solamente definir nuestro criterio de selecci\u00f3n en la iteraci\u00f3n con el contenido del texto, tambi\u00e9n podemos acceder a los atributos de los elementos utilizando el m\u00e9todo \u201cget()\u201d. # Ejemplo 3 import requests from bs4 import BeautifulSoup page = requests . get ( \u201c https : // datolok . github . io / python - edx / webscrapping / simple . html \u201d ) soup = BeautifulSoup ( page . content , \u2018 html . parser \u2019 ) for p in soup . find_all ( \u201c p \u201d ): if p . get ( \"class\" ) and \"outer-text\" in p . get ( \"class\" ) print ( p . get ( \u201c class \u201d ), p . get_text ()) plotly Proyecto Objetivo El objetivo del proyecto ser\u00e1 explorar, de manera b\u00e1sica, c\u00f3mo agregar anotaciones en nuestras gr\u00e1ficas generadas con plotly. En particular, aprender\u00e1s c\u00f3mo agregar anotaciones para se\u00f1alar puntos espec\u00edficos de la gr\u00e1fica de l\u00ednea que revisamos en el primer ejemplo de la unidad 5. Instrucciones Completa las partes faltantes del c\u00f3digo para obtener el siguiente resultado: \u200b La primera parte del c\u00f3digo, donde definimos los datos para graficar, es esta: 1 import numpy as np 2 import plotly.offline as pyo 3 import plotly.graph_objs as go 4 5 np.random.seed(42) 6 x_values = np.linspace(0, 1, 100) 7 y_values = np.random.randn(100) 8 9 #Calcular el promedio de los valores de y_values 10 y_avg = #Completar1 11 12 #Calcular el valor m\u00e1ximo de y_values 13 y_max = #Completar2 14 15 #Calcular el valor x_y_max tal que (x_y_max, y_max) sea el punto m\u00e1ximo de la gr\u00e1fica de l\u00ednea 16 x_y_max = #Completar3 Como mencionamos antes, este proyecto inicia igual que el ejemplo que revisamos en la unidad 5. Las primeras 7 l\u00edneas del c\u00f3digo son igual que en dicho ejemplo. En la l\u00ednea 10 deber\u00e1s completar el c\u00f3digo para que en la variable y_avg sea igual al promedio de los valores del array y_values . En la l\u00ednea 13 deber\u00e1s completar el c\u00f3digo para que en la variable y_max sea igual al valor m\u00e1ximo del array y_values . En la l\u00ednea 16 deber\u00e1s completar el c\u00f3digo para que la variable x_y_max tenga el valor tal que el punto (x_y_max, y_max) sea el punto m\u00e1ximo de la gr\u00e1fica de l\u00ednea. Observa que a estas partes faltantes las hemos etiquetado como #Completar1 , #Completar2 y #Completar3 , para poder hacer referencia a ellas despu\u00e9s. La segunda parte del c\u00f3digo, donde definimos las gr\u00e1ficas que visualizaremos, es esta: 17 18 trace1 = go . Scatter ( x = x_values , 19 y = y_values , 20 name = 'Datos' , 21 mode = 'lines' ) 22 23 #Definir los par\u00e1metros x e y de modo que: 24 #Se genere una l\u00ednea punteada horizontal a la altura del promedio de y_values 25 trace2 = go . Scatter ( x = #Completar4, 26 y = #Completar5, 27 name = 'Promedio' , 28 mode = 'lines' , 29 line = { 'dash' : 'dash' }) 30 31 data = [ trace1 , trace2 ] 32 layout = go . Layout ( title = 'Gr\u00e1fica de l\u00ednea' ) 33 fig = go . Figure ( data = data , layout = layout ) En la l\u00ednea 18 creamos el trace1 con un go.Scatter() , como vimos en el ejemplo de la unidad 5. En la l\u00ednea 25 creamos el trace2 tambi\u00e9n con go.Scatter() . Aqu\u00ed deber\u00e1s definir de manera apropiada los par\u00e1metros x e y (elementos #Completar4 y #Completar5 ), de modo que el resultado sea una l\u00ednea punteada horizontal que est\u00e9 a la altura del promedio de los valores del array y_values . Las l\u00edneas 31, 32 y 33 ya las hemos discutido en la unidad 5. La tercera y \u00faltima parte del c\u00f3digo, donde definimos las anotaciones que mencionamos al principio, es la siguiente: 34 35 #Definir los par\u00e1metros x e y de modo que esta anotaci\u00f3n apunte al valor m\u00e1ximo de la l\u00ednea 36 fig . add_annotation ( x = #Completar6, 37 y = #Completar7, 38 text = \"En x = {:.2f} alcanz\u00f3 su valor m\u00e1ximo de {:.2f} \" . format ( #Completar6, Completar7), 39 showarrow = True , 40 arrowhead = 5 ) 41 42 fig . add_annotation ( axref = 'x' , 43 ayref = 'y' , 44 x = 0.6 , 45 y = #Completar8, 46 ax = 0.5 , 47 ay =- 2 , 48 text = \"El promedio de los valores es {:.2f} \" . format ( #Completar8), 49 showarrow = True , 50 arrowhead = 5 ) 51 52 pyo . plot ( fig , filename = 'line_chart.html' ) En la l\u00ednea 36, mediante la funci\u00f3n fig.add_annotation() , agregamos la primera anotaci\u00f3n, que sirve para se\u00f1alar al punto m\u00e1ximo de la gr\u00e1fica de l\u00ednea. En las l\u00edneas 36 y 37, deber\u00e1s definir de manera apropiada los par\u00e1metros x e y para que esta anotaci\u00f3n apunte a dicho m\u00e1ximo. Observa que los elementos #Completar6 y #Completar7 tambi\u00e9n se usan en la l\u00ednea 38, donde se define el texto de la anotaci\u00f3n. En la l\u00ednea 42, mediante la funci\u00f3n fig.add_annotation() , agregamos la segunda anotaci\u00f3n, que sirve para se\u00f1alar a la l\u00ednea horizontal punteada. En la l\u00ednea 45, deber\u00e1s definir de manera apropiada el par\u00e1metro y para que dicha anotaci\u00f3n apunte al punto sobre dicha l\u00ednea horizontal punteada donde x=0.6. Observa que el elemento #Completar8 tambi\u00e9n se usa en la l\u00ednea 48, donde se define el texto de la anotaci\u00f3n. Introducci\u00f3n a las bases de Dash Dash es una biblioteca para crear tableros puramente en Python. https://dash.plotly.com/introduction Las componentes de HTML vienen de dash_html_components , que b\u00e1sicamente tiene un componente de Python para cada etiqueta HTML posible. https://dash.plotly.com/dash-html-components La otra biblioteca es dash_core_components que contiene son los componentes centrales, y esta ofrece un sistema de componentes interactivos de nivel superior en el que generar\u00e1 cosas como JavaScript, HTML y CSS a trav\u00e9s de la biblioteca React.JS, todo en Python. https://dash.plotly.com/dash-core-components Si deseas ver ejemplos m\u00e1s complejos de lo que se puede lograr con Plotly+Dash , te sugerimos revisar la galer\u00eda: https://dash-gallery.plotly.host/Portal/ En general nuestros c\u00f3digos de las siguientes unidades empezar\u00e1n importando estos m\u00f3dulos: import dash import dash_core_components as dcc import dash_html_components as html Recuerda que si a\u00fan no los tienes instalados, puedes obtenerlos usando, por ejemplo: \u200b pip install dash desde la terminal en PyCharm. Proyecto Objetivo El objetivo de este proyecto es utilizar elementos que revisamos durante este m\u00f3dulo 4 para construir un tablero en el que podamos analizar las variables de uno de los datasets que utilizamos en el m\u00f3dulo 3, el dataset iris . En particular, nuestro tablero nos permitir\u00e1 especificar algunos par\u00e1metros de un diagrama de dispersi\u00f3n: los ejes y los marginales . El resultado final debe verse de esta forma: \u200b Instrucciones Te presentamos la mayor parte del c\u00f3digo para generar el tablero antes descrito, sin embargo, este c\u00f3digo tiene partes faltantes que deber\u00e1s completar. Las ubicar\u00e1s donde hemos colocado etiquetas de tipo #Completar1. Esta es la primera parte del c\u00f3digo: 1 import dash 2 import dash_core_components as dcc 3 import dash_html_components as html 4 import pandas as pd 5 import plotly.express as px 6 from dash.dependencies import Input , Output 7 8 df = pd . read_csv ( 'Datasets/iris.csv' ) 9 10 variables = #Completar1 11 marginals = #Completar2 12 13 app = dash . Dash () Las primeras l\u00edneas son para importar las bibliotecas necesarias. En la l\u00ednea 8 creamos el dataframe df leyendo el dataset iris.csv . En la l\u00ednea 10 deber\u00e1s definir #Completar1 de modo que variables sirva como el par\u00e1metro options de los dropdowns que sirven para seleccionar variables del dataframe, con la restricci\u00f3n de que no incluya a la variable 'class'. En la l\u00ednea 11 deber\u00e1s definir #Completar2 de modo que marginals sirva como el par\u00e1metro options de los radio items que sirven para seleccionar alguno de los cuatro tipo de marginales: 'histogram', 'rug', 'box' y 'violin' . Luego, tenemos la segunda parte del c\u00f3digo, la m\u00e1s extensa: 15 app . layout = html . Div ([ html . Div ([ html . H1 ( 'An\u00e1lisis del dataset iris.csv' )], 16 style = { 'textAlign' : 'center' }), 17 html . Div ([ html . H3 ( 'Configuraci\u00f3n de par\u00e1metros de la gr\u00e1fica' )], 18 style = { 'marginLeft' : '5%' }), 19 html . Div ([ html . Label ( 'Selecciona la variable del eje X' ), 20 dcc . Dropdown ( id = 'eje-x' , options = #Completar3)], 21 style = { 'width' : '20%' , 22 'marginRight' : '3%' , 23 'marginLeft' : '5%' , 24 'verticalAlign' : 'top' , 25 'display' : 'inline-block' }), 26 html . Div ([ html . Label ( 'Selecciona el marginal del eje X' ), 27 dcc . RadioItems ( id = 'marginal-x' , options = #Completar4, labelStyle={'display': 'block'})], 28 style = { 'width' : '20%' , 29 'marginRight' : '4%' , 30 'display' : 'inline-block' }), 31 html . Div ([ html . Label ( 'Seleccionar la variable del eje Y' ), 32 dcc . Dropdown ( id = 'eje-y' , options = #Completar3)], 33 style = { 'width' : '20%' , 34 'marginRight' : '3%' , 35 'verticalAlign' : 'top' , 36 'display' : 'inline-block' }), 37 html . Div ([ html . Label ( 'Selecciona el marginal del eje Y' ), 38 dcc . RadioItems ( id = 'marginal-y' , options = #Completar4, labelStyle={'display': 'block'})], 39 style = { 'width' : '20%' , 40 'display' : 'inline-block' }), 41 html . Div ([ dcc . Graph ( id = 'scatter' )])]) Observa que en realidad esta parte del c\u00f3digo, donde definimos el layout de nuestro tablero, es extensa debido a que usamos muchos par\u00e1metros de tipo style, para poder darle la forma deseada a nuestro tablero, pero en realidad este layout tiene cinco elementos principales: dos dcc.Dropdown() , dos dcc.RadioItems() y un dcc.Graph() . En la l\u00ednea 20, deber\u00e1s definir #Completar3 de modo que el elemento dcc.Dropdown() de esa misma l\u00ednea sirva para poder seleccionar alguna de las variables del dataframe, y que se asigne al eje X. Observa que en la l\u00ednea 32 usamos ese mismo elemento para el eje Y. En la l\u00ednea 27, deber\u00e1s definir #Completar4 de modo que el elemento dcc.RadioItems() de esa misma l\u00ednea sirva para poder seleccionar alguna de las opciones de marginales que tenemos, y que se asigne al marginal del eje X. Observa que en la l\u00ednea 38 usamos ese mismo elemento para el eje Y. Todos los dem\u00e1s par\u00e1metros y elementos ya est\u00e1n definidos, y puedes modificarlos si gustas, sobre todo si alguno no te queda claro qu\u00e9 rol est\u00e1 jugando en la distribuci\u00f3n de los elementos del tablero, para explorar. Para que los elementos del tablero queden distribuidos como te presentamos previamente, la recomendaci\u00f3n es que uses las definiciones que te proponemos. Finalmente, la tercera y \u00faltima parte del c\u00f3digo es la siguiente: 43 @app . callback ( Output ( 'scatter' , 'figure' ), 44 [ Input ( 'eje-x' , 'value' ), 45 Input ( 'marginal-x' , 'value' ), 46 Input ( 'eje-y' , 'value' ), 47 Input ( 'marginal-y' , 'value' )]) 48 def update_outputs ( vx , mx , vy , my ): 49 fig = px . scatter ( df , 50 x = #Completar5, 51 y = #Completar6, 52 color = 'class' , 53 marginal_x = #Completar7, 54 marginal_y = #Completar8, 55 title = 'Diagrama de dispersi\u00f3n: ' + str ( #Completar5)+' v.s. '+str(#Completar6)) 56 return fig 57 58 if __name__ == '__main__' : 59 app . run_server () De la l\u00ednea 43 a la 56 definimos un callback, que recibe los cuatro valores que el usuario seleccion\u00f3 en los dropdowns y en los radio items, y actualiza el diagrama de dispersi\u00f3n, y los respectivos marginales de los ejes. En la l\u00ednea 50, deber\u00e1s definir #Completar5 de modo que al par\u00e1metro x le asignes la variable que el usuario seleccion\u00f3 en el dropdown del eje X. En la l\u00ednea 51, deber\u00e1s definir #Completar6 de modo que al par\u00e1metro y le asignes la variable que el usuario seleccion\u00f3 en el dropdown del eje Y. Observa que esos elementos, #Completar5 y #Completar6 , tambi\u00e9n se usan en la l\u00ednea 55, para actualizar el t\u00edtulo de la gr\u00e1fica. En la l\u00ednea 53, deber\u00e1s definir #Completar7 de modo que al par\u00e1metro marginal_x le asignes la opci\u00f3n de marginal que el usuario seleccion\u00f3 para el radio item del eje X. En la l\u00ednea 54, deber\u00e1s definir #Completar8 de modo que al par\u00e1metro marginal_y le asignes la opci\u00f3n de marginal que el usuario seleccion\u00f3 para el radio item del eje Y. Al guardar y ejecutar el c\u00f3digo completo, debes obtener un tablero como el que te presentamos al principio.","title":"py"},{"location":"web/py/#py","text":"","title":"py"},{"location":"web/py/#links","text":"Introduction to Python: Absolute Beginner (edX). Introducci\u00f3n al desarrollo de aplicaciones web (edx) ** de aqui es la documentacion Curso de Python B\u00e1sico Gratis (Web C\u00f3digo Facilito).","title":"links"},{"location":"web/py/#venv","text":"requirements.txt flask pk@pk:~$ type vvvv vvvv () { deactivate ; python3.8 -m venv ./.venv ; source ./.venv/bin/activate ; pip install -r requirements.txt ; python app.py } pk@pk:~$ pk@pk:~$","title":"venv"},{"location":"web/py/#flask","text":"","title":"flask"},{"location":"web/py/#ejemplo-basico","text":"app.py import sys from flask import Flask , request app = Flask ( __name__ ) @app . route ( '/' ) def index (): user_agent = request . headers . get ( 'User-Agent' ) return '<p>Your browser is %s </p>' % user_agent @app . route ( '/processLogin' , methods = [ 'POST' ]) def process_login (): missing = [] fields = [ 'email' , 'passwd' , 'login_submit' ] for field in fields : value = request . form . get ( field , None ) if value is None : missing . append ( field ) if missing : return \"Warning: Some fields are missing\" return '<!DOCTYPE html> ' \\ '<html lang=\"es\">' \\ '<head>' \\ '<link href=\"static/css/my-socnet-style.css\" rel=\"stylesheet\" type=\"text/css\"/>' \\ '<title> Home - SocNet </title>' \\ '</head>' \\ '<body> <div id =\"container\">' \\ '<a href=\"/\"> SocNet </a> | <a href=\"home\"> Home </a> | <a href=\"login\"> Log In </a> | <a href=\"signup\"> Sign Up </a>' \\ '<h1>Data from Form: Login</h1>' \\ '<form><label>email: ' + request . form [ 'email' ] + \\ '</label><br><label>passwd: ' + request . form [ 'passwd' ] + \\ '</label></form></div></body>' \\ '</html>' if __name__ == '__main__' : if sys . platform == 'ubuntu' : app . run ( debug = True , port = 8080 ) else : app . run ( debug = True , port = 80 ) index.html","title":"ejemplo basico"},{"location":"web/py/#flask-ejem-buenisimo-api-json","text":"''' http://127.0.0.1:8080/songs/all import requests cancion={ 'Artista':'dfasfd', 'Nombre':'jojo' } respuesta=requests.get('http://127.0.0.1:8080/songs/all') print('\\n',respuesta.content.decode()) respuesta=requests.post('http://127.0.0.1:8080/songs/new',json=cancion) print('\\n',respuesta.content.decode()) respuesta=requests.get('http://127.0.0.1:8080/songs/all') print('\\n',respuesta.content.decode()) respuesta=requests.patch('http://127.0.0.1:8080/songs/2', json={'Artista':'jijiji'}) print('\\n',respuesta.content.decode()) respuesta=requests.get('http://127.0.0.1:8080/songs/all') print('\\n',respuesta.content.decode()) ''' # Ejemplo API from flask import Flask , request , jsonify import json app = Flask ( __name__ ) song_db = [ { \"id\" : 0 , \"Artista\" : \"Air Supply\" , \"Nombre\" : \"Making Love Out of Nothing at All\" }, { \"id\" : 1 , \"Artista\" : \"Bonnie Tyle\" , \"Nombre\" : \"Total Eclipse Of The Heart\" }, { \"id\" : 2 , \"Artista\" : \"George Michael\" , \"Nombre\" : \"Careless Whisper\" }, { \"id\" : 3 , \"Artista\" : \"Berlin\" , \"Nombre\" : \"Take My Breath Away\" }, { \"id\" : 4 , \"Artista\" : \"Queen\" , \"Nombre\" : \"Bohemian Rhapsody\" } ] # GET | returns the whole catalog @app . route ( \"/songs/all\" , methods = [ \"GET\" ]) def get_all (): return jsonify ( song_db ), 200 # GET | returns an entry by an id @app . route ( \"/songs/<int:song_id>\" , methods = [ \"GET\" ]) def get_song ( song_id ): song_result = next ( ( song for song in song_db if song [ \"id\" ] == song_id ), None ) if song_result : return ( jsonify ( song_result ), 200 ) else : return \"404 Not Found\" , 404 # GET | returns all songs with the same name @app . route ( \"/songs/search/<string:song_name>\" , methods = [ \"GET\" ]) def search_song ( song_name ): songs = [ song for song in song_db if song_name in song [ \"Nombre\" ]] if songs : return ( jsonify ( songs ), 200 ) else : return \"404 Not Found\" , 404 # POST | creates a new entry in the catalog @app . route ( \"/songs/new\" , methods = [ \"POST\" ]) def post_song (): if request . data : song_data = json . loads ( request . data ) song_id = max ([ song [ 'id' ] for song in song_db ]) + 1 song_artist = song_data [ \"Artista\" ] song_name = song_data [ \"Nombre\" ] new_song = { \"id\" : song_id , \"Artista\" : song_artist , \"Nombre\" : song_name } song_db . append ( new_song ) return jsonify ( new_song ), 200 else : return \"400 Bad Request\" , 400 # DELETE | deletes an entry in the catalog by an id @app . route ( \"/songs/<int:song_id>\" , methods = [ \"DELETE\" ]) def delete_song ( song_id ): for idx , song in enumerate ( song_db ): if song [ \"id\" ] == song_id : song_db . pop ( idx ) return \"Register Deleted\" , 200 return \"Not Found\" , 404 # PUT | replaces an entry in the catalog, creates a new entry if it doesn't exist @app . route ( \"/songs/<int:song_id>\" , methods = [ \"PUT\" ]) def put_song ( song_id ): if request . data : song_data = json . loads ( request . data ) song_artist = song_data [ \"Artista\" ] song_name = song_data [ \"Nombre\" ] edit_song = { \"id\" : song_id , \"Artista\" : song_artist , \"Nombre\" : song_name } for idx , song in enumerate ( song_db ): if song [ \"id\" ] == song_id : song_db [ idx ] = edit_song return ( jsonify ( edit_song ), 200 ) edit_song [ \"id\" ] = max ([ song [ 'id' ] for song in song_db ]) + 1 song_db . append ( edit_song ) return ( jsonify ( edit_song ), 200 ) else : return \"Bad Request\" , 400 # PATCH | edits an entry in the catalog, fails if it doesn't exist @app . route ( \"/songs/<int:song_id>\" , methods = [ \"PATCH\" ]) def patch_song ( song_id ): if request . data : for idx , song in enumerate ( song_db ): if song [ \"id\" ] == song_id : song_data = json . loads ( request . data ) for edit_key in song_data : song [ edit_key ] = song_data [ edit_key ] return ( jsonify ( song ), 200 ) return \"Not Found\" , 404 else : return \"Bad Request\" , 400 if __name__ == '__main__' : app . run ( debug = True , port = 8080 )","title":"flask. ejem buenisimo api json"},{"location":"web/py/#json","text":"Las estructuras de JSON tienen una traducci\u00f3n directa a estructuras Python: Los objetos JSON son representados como diccionarios en Python Los arrays JSON son representados como listas en Python true y false en JSON son valores del tipo boolean en Python Las cadenas en JSON son cadenas en Python Los n\u00fameros en JSON son float o integer , seg\u00fan corresponda, en Python Por este motivo, las funciones para leer y escribir ficheros JSON son muy sencillas de utilizar. En ambos casos recurrimos a la biblioteca JSON, as\u00ed que lo primero que debemos hacer es: import json","title":"json"},{"location":"web/py/#lectura","text":"La funci\u00f3n para leer un fichero JSON es json.load. Como par\u00e1metro un fichero, as\u00ed que una forma normal de usarla es: with open(\u201cnombre_fichero.json\u201d, 'r') as f: data = json.load(f) Despu\u00e9s de ejecutar esto, la variable data contendr\u00e1 un diccionario con los datos cargados del fichero. Si por ejemplo hubi\u00e9ramos cargado el fichero con los datos del usuario James visto en la secci\u00f3n anterior, ahora data[\u2018user_name\u2019] ser\u00eda \u201cJames\u201d y data[\u2018messages\u2019] ser\u00eda una lista Python con los mensajes publicados por James.","title":"Lectura"},{"location":"web/py/#escritura","text":"Volcar una estructura Python a un fichero JSON es igual de sencillo. Supongamos que tenemos la siguiente inicializaci\u00f3n de la variable datos: da t os = { \"user_name\" : \"James\" , \"password\" : \u201c 007 \u201d , \"messages\" : [ ( 1532648502.113984 , \u201cme nsa je 1 \u201d) , ( 1532648642.729385 , \u201cme nsa je 1 \u201d) ], \"email\" : sessio n [ 'email' ], \"friends\" : sessio n [ ' fr ie n ds' ] } Entonces guardar los datos en el fichero correspondiente ser\u00eda: with open ( \u201c james . bond @mi6 . uk \u201d , 'w' ) as f : json . dump ( datos , f )","title":"Escritura"},{"location":"web/py/#sesiones","text":"Ya hemos dicho en varias oportunidades que el protocolo HTTP no tiene estado, que no recuerda. \u00bfQu\u00e9 significa eso en la pr\u00e1ctica? Que necesitamos informaci\u00f3n adicional para implementar una \u201cconversaci\u00f3n\u201d entre cliente y servidor. Esta idea de conversaci\u00f3n, donde ambas partes recuerdan lo que han hablado hasta el momento, se llama sesi\u00f3n . Aunque el concepto o la duraci\u00f3n de una sesi\u00f3n puede variar en distintos entornos, b\u00e1sicamente es el conjunto de interacciones entre cliente y servidor en un lapso de tiempo razonable. La primera vez que un cliente realiza una petici\u00f3n, despu\u00e9s de un tiempo sin interactuar, el servidor abre una sesi\u00f3n . Las subsecuentes peticiones desde ese cliente se consideran dentro de la misma sesi\u00f3n. Si pasa mucho tiempo sin que el cliente realice una petici\u00f3n, el servidor asume que ya no est\u00e1 conectado y termina la sesi\u00f3n. La biblioteca Flask nos ofrece este concepto de sesi\u00f3n. Pero si HTTP no tiene informaci\u00f3n espec\u00edfica que permita identificar al usuario o la sesi\u00f3n, \u00bfc\u00f3mo sabe Flask a qu\u00e9 usuario corresponde una determinada petici\u00f3n? Existen al menos 3 formas de que una petici\u00f3n HTTP transporte informaci\u00f3n que permita identificar al usuario o la sesi\u00f3n: Cookies : las cookies son peque\u00f1os ficheros que se adjuntan a una respuesta HTTP, con informaci\u00f3n de identificaci\u00f3n de usuario. En sucesivas peticiones HTTP, el navegador incluye ese fichero autom\u00e1ticamente, por lo que el servidor podr\u00e1 tener la identificaci\u00f3n de ese usuario. Campos ocultos : en los formularios que el servidor env\u00eda a cliente para que sean completados, incluyo un campo del tipo input que no se muestra al usuario; ese campo lleva informaci\u00f3n que cuando los datos del formulario se env\u00eden de vuelta al servidor le servir\u00e1 para identificar al cliente. Reescritura de URLs : aunque nos parezcan iguales, el servidor introduce autom\u00e1ticamente peque\u00f1as modificaciones a las URLs; de esta forma, la URL espec\u00edfica que solicite permitir\u00e1 al servidor identificar al cliente. La buena noticia es que, generalmente, el mecanismo que se use para transportar la informaci\u00f3n de sesi\u00f3n no es visible al desarrollador de la aplicaci\u00f3n web. Esto es exactamente lo que ocurre con el soporte de sesiones que nos ofrece Flask, y que veremos a continuaci\u00f3n. Vamos a ver c\u00f3mo podemos manejar una sesi\u00f3n en Python y Flask para poder almacenar informaci\u00f3n entre cada una de las peticiones que el cliente haga al servidor.","title":"sesiones"},{"location":"web/py/#objeto-flask-session","text":"El objeto que nos guarda la informaci\u00f3n entre sesiones se llama session. Lo primero ser\u00e1 importarlo dentro de nuestro c\u00f3digo Python para luego poder usarlo: from flask import Flask, session Como la informaci\u00f3n de la sesi\u00f3n viaja del servidor al cliente ida y vuelta, es importante que nadie en el camino, ni siquiera el propio cliente, puedan alterar esa informaci\u00f3n. En particular, se debe evitar que alguien de fuera \u201ctome control\u201d de la sesi\u00f3n. En seguridad inform\u00e1tica, este tipo de ataque se conoce como CSRF (Cross-site request forgery) o robo de sesi\u00f3n. Para asegurarse que eso no ocurre, Flask utiliza t\u00e9cnicas de encriptaci\u00f3n para proteger la informaci\u00f3n. Para eso, necesita una clav de encriptaci\u00f3n/desencriptaci\u00f3n. Esta clave, que s\u00f3lo debe conocer el servidor y que debe ser distinta para todos los programas servidor, se crea en el propio c\u00f3digo del servidor. Por ejemplo: app.secret_key = 'esto-es-una-clave-muy-secreta' De hecho, en el c\u00f3digo de nuestra aplicaci\u00f3n SocNet habr\u00e1s visto una l\u00ednea similar a esta: app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT' Ahora ya sabes para qu\u00e9 sirve. Si quieres tener m\u00e1s informaci\u00f3n de este problema de seguridad inform\u00e1tica y su soluci\u00f3n, puedes leer aqu\u00ed . Ahora vamos a ver ejemplo de c\u00f3mo utilizamos las sesiones en nuestra aplicaci\u00f3n favorita. La primera funci\u00f3n, *load_user(email, passwd)* , intenta cargar los datos desde un fichero. Importante : aqu\u00ed almacenamos los datos en un fichero por una cuesti\u00f3n de simplicidad. En aplicaciones con cientos o miles de usuarios lo normal es almacenar los datos en una base de datos propiamente dicha. Si el fichero existe, carga los datos y a continuaci\u00f3n comprueba que la clave suministrada coincida con la que est\u00e1 almacenada. Nota de seguridad : otra vez, para facilitar las explicaciones y la comprensi\u00f3n de los conceptos b\u00e1sicos, realizamos algunas simplificaciones que antes de hacer p\u00fablico un sistema deben ser corregidas. Por ejemplo, nunca se debe guardar una clave de usuario \u201cen claro\u201d, siempre se debe hacer codificada con alg\u00fan algoritmo como por ejemplo SHA-256. Lamentable estas cuestiones quedan fuera del \u00e1mbito de este curso. Si todas las condiciones son correctas, la funci\u00f3n guarda los datos relevantes del usuario (nombre, mensajes que ha escrito hasta el momento, la clave, su correo electr\u00f3nico y la lista de amigos) en la sesi\u00f3n , para que est\u00e9n disponibles para las pr\u00f3xima llamadas desde el cliente. def load_user ( email , passwd ): \"\"\" It loads data for the given user (identified by email) from the data directory. It looks for a file whose name matches the user email :param email: user id :param passwd: password to check in order to validate the user :return: content of the home page (app basic page) if user exists and password is correct \"\"\" file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if not os . path . isfile ( file_path ): return process_error ( \"User not found / No existe un usuario con ese nombre\" , url_for ( \"login\" )) with open ( file_path , 'r' ) as f : data = json . load ( f ) if data [ 'password' ] != passwd : return process_error ( \"Incorrect password / la clave no es correcta\" , url_for ( \"login\" )) session [ 'user_name' ] = data [ 'user_name' ] session [ 'messages' ] = data [ 'messages' ] session [ 'password' ] = passwd session [ 'email' ] = email session [ 'friends' ] = data [ 'friends' ] return redirect ( url_for ( \"home\" )) De la misma forma, cuando un usuario quiere salir del sistema, debemos guardar los datos en el fichero (base de datos) para que est\u00e9n disponibles la pr\u00f3xima vez que el usuario vuelva a nuestra aplicaci\u00f3n. Este es el objetivo de la funci\u00f3n save_current_user() , que vuelca los datos de session en el fichero correspondiente. Por otra parte, cuando un usuario se da de alta, se debe crear el fichero, previa comprobaci\u00f3n que no exista un usuario con el mismo identificador (correo electr\u00f3nico). Esto es lo que hace la funci\u00f3n create_user_file(name, email, passwd, passwd_confirmation) . def save_current_user (): datos = { \"user_name\" : session [ \"user_name\" ], \"password\" : session [ 'password' ], \"messages\" : session [ 'messages' ], # lista de tuplas (time_stamp, mensaje) \"email\" : session [ 'email' ], \"friends\" : session [ 'friends' ] } file_path = os . path . join ( SITE_ROOT , \"data/\" , session [ 'email' ]) with open ( file_path , 'w' ) as f : json . dump ( datos , f ) def create_user_file ( name , email , passwd , passwd_confirmation ): \"\"\" It creates the file (in the /data directory) for storing user data. The file name will match the user email. If the file already exists, it returns an error. If the password does not match the confirmation, it returns an error. :param name: Name or nickname of the user :param email: user email, which will be later used for retrieving data :param passwd: password for future logins :param passwd_confirmation: confirmation, must match the password :return: if no error is found, it sends the user to the home page \"\"\" directory = os . path . join ( SITE_ROOT , \"data\" ) if not os . path . exists ( directory ): os . makedirs ( directory ) file_path = os . path . join ( SITE_ROOT , \"data/\" , email ) if os . path . isfile ( file_path ): return process_error ( \"The email is already used, you must select a different email / Ya existe un usuario con ese nombre\" , url_for ( \"signup\" )) if passwd != passwd_confirmation : return process_error ( \"Your password and confirmation password do not match / Las claves no coinciden\" , url_for ( \"signup\" )) datos = { \"user_name\" : name , \"password\" : passwd , \"messages\" : [], \"friends\" : [] } with open ( file_path , 'w' ) as f : json . dump ( datos , f ) session [ 'user_name' ] = name session [ 'password' ] = passwd session [ 'messages' ] = [] session [ 'friends' ] = [] session [ 'email' ] = email return redirect ( url_for ( \"home\" ))","title":"Objeto Flask Session"},{"location":"web/py/#iterando-sobre-los-elementos-en-beautiful-soup","text":"Hasta el momento se han visto dos principales maneras de c\u00f3mo se puede utilizar el \u00e1rbol jer\u00e1rquico producido por BeautifulSoup con base a una p\u00e1gina web: utilizando m\u00e9todos de b\u00fasqueda, y navegando manualmente por los elementos, cada uno con sus ventajas y desventajas. Sin embargo, podemos utilizar un enfoque intermedio entre estos dos extremos y es el de utilizar m\u00e9todos de iteraci\u00f3n sobre los elementos. De esta forma podemos tener la ventaja de la flexibilidad de la b\u00fasqueda, pero con el poder de ajustar la selecci\u00f3n de los elementos de forma manual. Para lograr este objetivo, BeautifulSoup cuenta con diferentes herramientas y m\u00e9todos,siendo uno de ellos el atributo \u201c descendants \u201d. Su comportamiento es similar al de \u201c children \u201d pero no solo se limita a los elementos inmediatos, si no que enlista todos los elementos, es decir, los hijos, los hijos de los hijos, etc. # Ejemplo 1 import requests from bs4 import BeautifulSoup page = requests . get ( \u201c https : // datolok . github . io / python - edx / webscrapping / simple . html \u201d ) soup = BeautifulSoup ( page . content , \u2018 html . parser \u2019 ) for element in soup . descendants : print ( \"Element {} : \\n {} \" . format ( item , element )) En este c\u00f3digo se carga la p\u00e1gina que se ha utilizado de ejemplo y se imprimen todos los elementos contenidos por medio de un ciclo for. Esto se puede combinar con otros conceptos, como la de expresiones regulares, para identificar palabras claves o patrones de informaci\u00f3n. Este proceso de b\u00fasqueda dentro de un elemento en particular puede aplicarse al resultado de otros procesos como el de b\u00fasqueda o navegaci\u00f3n. # Ejemplo 2 import requests from bs4 import BeautifulSoup page = requests . get ( \u201c https : // datolok . github . io / python - edx / webscrapping / simple . html \u201d ) soup = BeautifulSoup ( page . content , \u2018 html . parser \u2019 ) for p in soup . find_all ( \u201c p \u201d ): if \u201c contenido \u201d in p . get_text (): print ( p . get_text ()) En este c\u00f3digo se encuentran todos los elementos de tipo p\u00e1rrafo en el documento, se iteran sobre todos los resultados y se imprimen aquellos que contengan la palabra \u201ccontenido\u201d. Como se puede observar esto abre un abanico de nuevas posibilidades para automatizar nuestro proceso de b\u00fasqueda y no depender demasiado en que la estructura de la p\u00e1gina web no var\u00ede. Igualmente, no estamos limitados a solamente definir nuestro criterio de selecci\u00f3n en la iteraci\u00f3n con el contenido del texto, tambi\u00e9n podemos acceder a los atributos de los elementos utilizando el m\u00e9todo \u201cget()\u201d. # Ejemplo 3 import requests from bs4 import BeautifulSoup page = requests . get ( \u201c https : // datolok . github . io / python - edx / webscrapping / simple . html \u201d ) soup = BeautifulSoup ( page . content , \u2018 html . parser \u2019 ) for p in soup . find_all ( \u201c p \u201d ): if p . get ( \"class\" ) and \"outer-text\" in p . get ( \"class\" ) print ( p . get ( \u201c class \u201d ), p . get_text ())","title":"Iterando sobre los elementos en Beautiful Soup"},{"location":"web/py/#plotly","text":"","title":"plotly"},{"location":"web/py/#proyecto","text":"","title":"Proyecto"},{"location":"web/py/#objetivo","text":"El objetivo del proyecto ser\u00e1 explorar, de manera b\u00e1sica, c\u00f3mo agregar anotaciones en nuestras gr\u00e1ficas generadas con plotly. En particular, aprender\u00e1s c\u00f3mo agregar anotaciones para se\u00f1alar puntos espec\u00edficos de la gr\u00e1fica de l\u00ednea que revisamos en el primer ejemplo de la unidad 5.","title":"Objetivo"},{"location":"web/py/#instrucciones","text":"Completa las partes faltantes del c\u00f3digo para obtener el siguiente resultado: \u200b La primera parte del c\u00f3digo, donde definimos los datos para graficar, es esta: 1 import numpy as np 2 import plotly.offline as pyo 3 import plotly.graph_objs as go 4 5 np.random.seed(42) 6 x_values = np.linspace(0, 1, 100) 7 y_values = np.random.randn(100) 8 9 #Calcular el promedio de los valores de y_values 10 y_avg = #Completar1 11 12 #Calcular el valor m\u00e1ximo de y_values 13 y_max = #Completar2 14 15 #Calcular el valor x_y_max tal que (x_y_max, y_max) sea el punto m\u00e1ximo de la gr\u00e1fica de l\u00ednea 16 x_y_max = #Completar3 Como mencionamos antes, este proyecto inicia igual que el ejemplo que revisamos en la unidad 5. Las primeras 7 l\u00edneas del c\u00f3digo son igual que en dicho ejemplo. En la l\u00ednea 10 deber\u00e1s completar el c\u00f3digo para que en la variable y_avg sea igual al promedio de los valores del array y_values . En la l\u00ednea 13 deber\u00e1s completar el c\u00f3digo para que en la variable y_max sea igual al valor m\u00e1ximo del array y_values . En la l\u00ednea 16 deber\u00e1s completar el c\u00f3digo para que la variable x_y_max tenga el valor tal que el punto (x_y_max, y_max) sea el punto m\u00e1ximo de la gr\u00e1fica de l\u00ednea. Observa que a estas partes faltantes las hemos etiquetado como #Completar1 , #Completar2 y #Completar3 , para poder hacer referencia a ellas despu\u00e9s. La segunda parte del c\u00f3digo, donde definimos las gr\u00e1ficas que visualizaremos, es esta: 17 18 trace1 = go . Scatter ( x = x_values , 19 y = y_values , 20 name = 'Datos' , 21 mode = 'lines' ) 22 23 #Definir los par\u00e1metros x e y de modo que: 24 #Se genere una l\u00ednea punteada horizontal a la altura del promedio de y_values 25 trace2 = go . Scatter ( x = #Completar4, 26 y = #Completar5, 27 name = 'Promedio' , 28 mode = 'lines' , 29 line = { 'dash' : 'dash' }) 30 31 data = [ trace1 , trace2 ] 32 layout = go . Layout ( title = 'Gr\u00e1fica de l\u00ednea' ) 33 fig = go . Figure ( data = data , layout = layout ) En la l\u00ednea 18 creamos el trace1 con un go.Scatter() , como vimos en el ejemplo de la unidad 5. En la l\u00ednea 25 creamos el trace2 tambi\u00e9n con go.Scatter() . Aqu\u00ed deber\u00e1s definir de manera apropiada los par\u00e1metros x e y (elementos #Completar4 y #Completar5 ), de modo que el resultado sea una l\u00ednea punteada horizontal que est\u00e9 a la altura del promedio de los valores del array y_values . Las l\u00edneas 31, 32 y 33 ya las hemos discutido en la unidad 5. La tercera y \u00faltima parte del c\u00f3digo, donde definimos las anotaciones que mencionamos al principio, es la siguiente: 34 35 #Definir los par\u00e1metros x e y de modo que esta anotaci\u00f3n apunte al valor m\u00e1ximo de la l\u00ednea 36 fig . add_annotation ( x = #Completar6, 37 y = #Completar7, 38 text = \"En x = {:.2f} alcanz\u00f3 su valor m\u00e1ximo de {:.2f} \" . format ( #Completar6, Completar7), 39 showarrow = True , 40 arrowhead = 5 ) 41 42 fig . add_annotation ( axref = 'x' , 43 ayref = 'y' , 44 x = 0.6 , 45 y = #Completar8, 46 ax = 0.5 , 47 ay =- 2 , 48 text = \"El promedio de los valores es {:.2f} \" . format ( #Completar8), 49 showarrow = True , 50 arrowhead = 5 ) 51 52 pyo . plot ( fig , filename = 'line_chart.html' ) En la l\u00ednea 36, mediante la funci\u00f3n fig.add_annotation() , agregamos la primera anotaci\u00f3n, que sirve para se\u00f1alar al punto m\u00e1ximo de la gr\u00e1fica de l\u00ednea. En las l\u00edneas 36 y 37, deber\u00e1s definir de manera apropiada los par\u00e1metros x e y para que esta anotaci\u00f3n apunte a dicho m\u00e1ximo. Observa que los elementos #Completar6 y #Completar7 tambi\u00e9n se usan en la l\u00ednea 38, donde se define el texto de la anotaci\u00f3n. En la l\u00ednea 42, mediante la funci\u00f3n fig.add_annotation() , agregamos la segunda anotaci\u00f3n, que sirve para se\u00f1alar a la l\u00ednea horizontal punteada. En la l\u00ednea 45, deber\u00e1s definir de manera apropiada el par\u00e1metro y para que dicha anotaci\u00f3n apunte al punto sobre dicha l\u00ednea horizontal punteada donde x=0.6. Observa que el elemento #Completar8 tambi\u00e9n se usa en la l\u00ednea 48, donde se define el texto de la anotaci\u00f3n.","title":"Instrucciones"},{"location":"web/py/#introduccion-a-las-bases-de-dash","text":"","title":"Introducci\u00f3n a las bases de Dash"},{"location":"web/py/#dash-es-una-biblioteca-para-crear-tableros-puramente-en-python","text":"https://dash.plotly.com/introduction Las componentes de HTML vienen de dash_html_components , que b\u00e1sicamente tiene un componente de Python para cada etiqueta HTML posible. https://dash.plotly.com/dash-html-components La otra biblioteca es dash_core_components que contiene son los componentes centrales, y esta ofrece un sistema de componentes interactivos de nivel superior en el que generar\u00e1 cosas como JavaScript, HTML y CSS a trav\u00e9s de la biblioteca React.JS, todo en Python. https://dash.plotly.com/dash-core-components Si deseas ver ejemplos m\u00e1s complejos de lo que se puede lograr con Plotly+Dash , te sugerimos revisar la galer\u00eda: https://dash-gallery.plotly.host/Portal/ En general nuestros c\u00f3digos de las siguientes unidades empezar\u00e1n importando estos m\u00f3dulos: import dash import dash_core_components as dcc import dash_html_components as html Recuerda que si a\u00fan no los tienes instalados, puedes obtenerlos usando, por ejemplo: \u200b pip install dash desde la terminal en PyCharm.","title":"Dash es una biblioteca para crear tableros puramente en Python."},{"location":"web/py/#proyecto_1","text":"","title":"Proyecto"},{"location":"web/py/#objetivo_1","text":"El objetivo de este proyecto es utilizar elementos que revisamos durante este m\u00f3dulo 4 para construir un tablero en el que podamos analizar las variables de uno de los datasets que utilizamos en el m\u00f3dulo 3, el dataset iris . En particular, nuestro tablero nos permitir\u00e1 especificar algunos par\u00e1metros de un diagrama de dispersi\u00f3n: los ejes y los marginales . El resultado final debe verse de esta forma: \u200b","title":"Objetivo"},{"location":"web/py/#instrucciones_1","text":"Te presentamos la mayor parte del c\u00f3digo para generar el tablero antes descrito, sin embargo, este c\u00f3digo tiene partes faltantes que deber\u00e1s completar. Las ubicar\u00e1s donde hemos colocado etiquetas de tipo #Completar1. Esta es la primera parte del c\u00f3digo: 1 import dash 2 import dash_core_components as dcc 3 import dash_html_components as html 4 import pandas as pd 5 import plotly.express as px 6 from dash.dependencies import Input , Output 7 8 df = pd . read_csv ( 'Datasets/iris.csv' ) 9 10 variables = #Completar1 11 marginals = #Completar2 12 13 app = dash . Dash () Las primeras l\u00edneas son para importar las bibliotecas necesarias. En la l\u00ednea 8 creamos el dataframe df leyendo el dataset iris.csv . En la l\u00ednea 10 deber\u00e1s definir #Completar1 de modo que variables sirva como el par\u00e1metro options de los dropdowns que sirven para seleccionar variables del dataframe, con la restricci\u00f3n de que no incluya a la variable 'class'. En la l\u00ednea 11 deber\u00e1s definir #Completar2 de modo que marginals sirva como el par\u00e1metro options de los radio items que sirven para seleccionar alguno de los cuatro tipo de marginales: 'histogram', 'rug', 'box' y 'violin' . Luego, tenemos la segunda parte del c\u00f3digo, la m\u00e1s extensa: 15 app . layout = html . Div ([ html . Div ([ html . H1 ( 'An\u00e1lisis del dataset iris.csv' )], 16 style = { 'textAlign' : 'center' }), 17 html . Div ([ html . H3 ( 'Configuraci\u00f3n de par\u00e1metros de la gr\u00e1fica' )], 18 style = { 'marginLeft' : '5%' }), 19 html . Div ([ html . Label ( 'Selecciona la variable del eje X' ), 20 dcc . Dropdown ( id = 'eje-x' , options = #Completar3)], 21 style = { 'width' : '20%' , 22 'marginRight' : '3%' , 23 'marginLeft' : '5%' , 24 'verticalAlign' : 'top' , 25 'display' : 'inline-block' }), 26 html . Div ([ html . Label ( 'Selecciona el marginal del eje X' ), 27 dcc . RadioItems ( id = 'marginal-x' , options = #Completar4, labelStyle={'display': 'block'})], 28 style = { 'width' : '20%' , 29 'marginRight' : '4%' , 30 'display' : 'inline-block' }), 31 html . Div ([ html . Label ( 'Seleccionar la variable del eje Y' ), 32 dcc . Dropdown ( id = 'eje-y' , options = #Completar3)], 33 style = { 'width' : '20%' , 34 'marginRight' : '3%' , 35 'verticalAlign' : 'top' , 36 'display' : 'inline-block' }), 37 html . Div ([ html . Label ( 'Selecciona el marginal del eje Y' ), 38 dcc . RadioItems ( id = 'marginal-y' , options = #Completar4, labelStyle={'display': 'block'})], 39 style = { 'width' : '20%' , 40 'display' : 'inline-block' }), 41 html . Div ([ dcc . Graph ( id = 'scatter' )])]) Observa que en realidad esta parte del c\u00f3digo, donde definimos el layout de nuestro tablero, es extensa debido a que usamos muchos par\u00e1metros de tipo style, para poder darle la forma deseada a nuestro tablero, pero en realidad este layout tiene cinco elementos principales: dos dcc.Dropdown() , dos dcc.RadioItems() y un dcc.Graph() . En la l\u00ednea 20, deber\u00e1s definir #Completar3 de modo que el elemento dcc.Dropdown() de esa misma l\u00ednea sirva para poder seleccionar alguna de las variables del dataframe, y que se asigne al eje X. Observa que en la l\u00ednea 32 usamos ese mismo elemento para el eje Y. En la l\u00ednea 27, deber\u00e1s definir #Completar4 de modo que el elemento dcc.RadioItems() de esa misma l\u00ednea sirva para poder seleccionar alguna de las opciones de marginales que tenemos, y que se asigne al marginal del eje X. Observa que en la l\u00ednea 38 usamos ese mismo elemento para el eje Y. Todos los dem\u00e1s par\u00e1metros y elementos ya est\u00e1n definidos, y puedes modificarlos si gustas, sobre todo si alguno no te queda claro qu\u00e9 rol est\u00e1 jugando en la distribuci\u00f3n de los elementos del tablero, para explorar. Para que los elementos del tablero queden distribuidos como te presentamos previamente, la recomendaci\u00f3n es que uses las definiciones que te proponemos. Finalmente, la tercera y \u00faltima parte del c\u00f3digo es la siguiente: 43 @app . callback ( Output ( 'scatter' , 'figure' ), 44 [ Input ( 'eje-x' , 'value' ), 45 Input ( 'marginal-x' , 'value' ), 46 Input ( 'eje-y' , 'value' ), 47 Input ( 'marginal-y' , 'value' )]) 48 def update_outputs ( vx , mx , vy , my ): 49 fig = px . scatter ( df , 50 x = #Completar5, 51 y = #Completar6, 52 color = 'class' , 53 marginal_x = #Completar7, 54 marginal_y = #Completar8, 55 title = 'Diagrama de dispersi\u00f3n: ' + str ( #Completar5)+' v.s. '+str(#Completar6)) 56 return fig 57 58 if __name__ == '__main__' : 59 app . run_server () De la l\u00ednea 43 a la 56 definimos un callback, que recibe los cuatro valores que el usuario seleccion\u00f3 en los dropdowns y en los radio items, y actualiza el diagrama de dispersi\u00f3n, y los respectivos marginales de los ejes. En la l\u00ednea 50, deber\u00e1s definir #Completar5 de modo que al par\u00e1metro x le asignes la variable que el usuario seleccion\u00f3 en el dropdown del eje X. En la l\u00ednea 51, deber\u00e1s definir #Completar6 de modo que al par\u00e1metro y le asignes la variable que el usuario seleccion\u00f3 en el dropdown del eje Y. Observa que esos elementos, #Completar5 y #Completar6 , tambi\u00e9n se usan en la l\u00ednea 55, para actualizar el t\u00edtulo de la gr\u00e1fica. En la l\u00ednea 53, deber\u00e1s definir #Completar7 de modo que al par\u00e1metro marginal_x le asignes la opci\u00f3n de marginal que el usuario seleccion\u00f3 para el radio item del eje X. En la l\u00ednea 54, deber\u00e1s definir #Completar8 de modo que al par\u00e1metro marginal_y le asignes la opci\u00f3n de marginal que el usuario seleccion\u00f3 para el radio item del eje Y. Al guardar y ejecutar el c\u00f3digo completo, debes obtener un tablero como el que te presentamos al principio.","title":"Instrucciones"}]}